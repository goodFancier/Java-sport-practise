/*
** Баги в наименовании
*/
// сеттер для поля isNeedToCalculateAllShops
needToCalculateAllShops - setNeedToCalculateAllShops

// метод, вызываемый при изменении вкладки
changeTab - onChangeTab

// Обновить статус товара
statusDelivered - updateOrderStatus


/*
** Рефакторинг имен переменных
*/
sqlTimeConditions - timeConditions

sqlShopsConditions - shopConditions

sqlConditionList - conditions

sqlBrandConditionList - brandConditions

tabId - planningTabId

allDetailingObjects - detailingObjectList

availableYears - availableYearList

filterYears - filterYearQueue

sizesOfPlanValues - planValueListSize

name - buyerName

age - buyerAge

order - receiptOrder

checkedSignificantBrandList - checkedSignificantBrands

getIsNeedToShowAddDialog - isNeedToShowDialog

/*
** Имена переменных
*/

// 7.1
processCompleted - isProcessCompleted

isNeedToUpdate - doNeedUpdate

isCalculatingError - hasCalculatingError

isMessageSendingStopped - doMailingStopped

queryRunning - isQueryRunning

// 7.2
processFinished - isProcessDone

isElementExists - isElementFound

// 7.3

i - element

// 7.4
isMailingStarted, isMailingFinished - isMailingBegin, isMailingEnd

// 7.5
tmpSelectItemChecks - selectItemChecks
tmpStart - dateStart
tmpFinish - dateFinish

/*
** Имена, которых следует избегать
*/

allChannelsForRetailer - allChannels

filteredByEmailAndSmsChannelList - emailSmsChannels

addChannelsNotification - allowAllChannelsToBuyer

channelsDtoDualListModel - channelDualList

consumerList - consumers

goodsValue - goodsCount

buyerList1 - buyerOriginalList

buyerList2 - buyerProcessedList

retailerObject - retailer

guaranteedMessageDeliveryScheduler - msgDeliveryScheduler

max - maxSumOfCheck

value - checkValue

/*
** Имена классов
*/

// 3.1
CreatePage - PageConstructor

RuleManager - RuleController

EntityInfo - EntityPayload

CheckDeserializeProcessor - CheckDeserializer

CardDeserializeProcessor - CardDeserializer

// 3.2

initCheckFile - initDocument (реализация абстрактного метода)

initCardFile - initDocument (реализация абстрактного метода)

applyDiscountMechanic - applyMechanic (реализация абстрактного метода)

applyBonusMechanic - applyMechanic (реализация абстрактного метода)

bonusRuleManager - ruleManager

discountRuleManager - ruleManager

pull - pullResult

/*
** Имена функций/методов
*/

sendMessageAndCheckDelivery - sendMessage() - checkDelivery() - разделил один метод на два, убрав побочные действия метода

runSmsExecutorAndSaveToFile - runSmsExecutor() - saveResultToFile() - разделил один метод на два, убрав побочные действия метода

getViberJSONObjectAndSendMessage - getViberJSON() - sendMessage() - разделил один метод на два, убрав побочные действия метода

editName - setName - переименовал метод для изменения имени

reloadPage() - reload() - поправил название метода, т.к метод reload относится к классу Page

sendMessage() - send() - поправил название метода, т.к метод send относится к классу Message

taxiOrderToComplete() - completeTaxiOrder() - поправил название метода

lastMessageToFind() - findLastMessage() - поправил название метода

pageReload() - reloadPage() - поправил название метода

Element element = prevElement.add(20) - int element = prevElement.setIndex(20) - переименовал методв add в setIndex

Date date = prevDate.add(20) - Date date = prevDate.addMinutes(20);

entityToUpdate() - updateEntity() - поправил название метода

/*
** ООП и интерфейсы
*/

// 3.1
//  Метод-фабрика DataServiceFactory
    public static synchronized DataServiceFactory getInstance()
    		{
    				if(instance == null)
    						synchronized(DataServiceFactory.class)
    						{
    								try
    								{
    										if(instance == null)
    										{
    												InitialContext context = new InitialContext();
    												instance = (DataServiceFactory)context.lookup("java:module/DataServiceFactory");
    										}
    								}
    								catch(Exception e)
    								{
    										ExceptionHandler.handle(e);
    								}
    						}
    				return instance;
    		}

// Метод-фабрика AuditoryOperatorFactory
AuditoryOperatorFactory auditoryOperatorFactory = new AuditoryOperatorFactory(stock) - AuditoryOperatorFactory.fromStock(stock);

// Метод-фабрика BonusOperatorFactory
BonusOperatorFactory bonusOperatorFactory = new BonusOperatorFactory(bonus) - BonusOperatorFactory.fromBonus(bonus);

// 3.2
IDiscountMechanic - DiscountMechanic
IRuleManager - RuleManager
IBonusMechanic - BonusMechanic

/*
** Константы
*/

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String NumberParamName = "number";
public CardJSON register(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(NumberParamName) String number) throws Exception

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String CardIDParamName = "cardID";

public CardJSON getCard(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(CardIDParamName) Long cardID)
	{
		return getJSON(DataServiceFactory.intance().getCardsService().findById(cardID));
	}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String LoginParamName = "login";

	public BuyerJSON loginByHashPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(LoginParamName) String cardNumber,
			@NonNull String password,
			@QueryParam(DeviceParamName) String deviceID) throws Exception
		{
				return internalLogin(retailer, cardNumber, password, deviceID);
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
public static final String PasswordParamName = "password";

public BuyerJSON loginByPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(LoginParamName) String cardNumber,
			@NonNull @QueryParam(PasswordParamName) String password,
			@QueryParam(DeviceParamName) String deviceID,
			@QueryParam(BuyerIDParamName) Long buyerID,
			@QueryParam(BaseRestORMService.isNewLogic) Boolean... newLogic) throws Exception
		{
				if(newLogic.length > 0)
						return internalLogin(retailer, cardNumber, password, deviceID, buyerID);
				else
						return internalLogin(retailer, cardNumber, password, deviceID);
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String CardNumberParamName = "cardNumber";

	@POST
		@Path("/register/material4")
		@AccessAll
		public BuyerJSON registrationMaterialByHashPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailerCode,
			@NotNull @QueryParam(BaseRestORMService.BuyerParamName) BuyerJSON buyer,
			@NonNull @QueryParam(CardNumberParamName) String login,
			@NonNull String password,
			@QueryParam(DeviceParamName) String gmcid) throws Exception
		{
				return internalRegisterMaterial(retailerCode, login, password, gmcid, (o) -> createFromJSON(buyer));
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String DeviceCheckParamName = "deviceCheck";

//Скидка по умолчанию
private static final Double DefaultDiscount = 0d;

// Формат даты
private static final DateFormat SimpleDateFormat = new SimpleDateFormat("yyyyMMdd");

// Формат даты
private static final DateFormat BirthDayDateFormat = new SimpleDateFormat("MMdd");

// Формат даты
private static final SimpleDateFormat GUIDateTimeFormat = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");

// Формат даты
private static final SimpleDateFormat JQPlotDateTimeFormat = new SimpleDateFormat("MM.dd.yyyy HH:mm");

// Формат даты
private static final DateFormat FilenameDateTimeFormat = new SimpleDateFormat("ddMMyyyy HHmm");



/*
** Типы данных
*/

// использование unicode
String json = new String(body, StandardCharsets.UTF_8);

// Добавлена проверка на 0
if (checkItem.getQuantity() <> 0)
    checkItem.setPrice(checkItem.getSum().divide(checkItem.getQuantity()));

// Добавлена локализация
CategoryAxis axisX = new CategoryAxis(Localization.loadString("IndicatorController.categoryAxis.label.months"));

// Добавлена локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("IndicatorController.lineChartModel.axisY.label.checkNumber"));

// Добавлена локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("IndicatorController.lineChartModel.axisY.label.buyerNumber"));


// Дополнительные булевые переменные
// Было
if(MechanicManager.getInstance().getDiscountMechanics()
									.get(buyerDiscountStocks.get(i).getStockDiscountMechanic() != null? buyerDiscountStocks.get(i).getStockDiscountMechanic(): StockDiscountMechanicEnum.DiscountOnGood)
									.isCheckItemFitsRequirements(processedCheck, processedCheckItem, buyerDiscountStocks.get(i)))

// Стало

Boolean isCheckFitsRequirements = MechanicManager.getInstance().getDiscountMechanics()
									.get(buyerDiscountStocks.get(i).getStockDiscountMechanic() != null? buyerDiscountStocks.get(i).getStockDiscountMechanic(): StockDiscountMechanicEnum.DiscountOnGood)
									.isCheckItemFitsRequirements(processedCheck, processedCheckItem, buyerDiscountStocks.get(i))
									if (isCheckFitsRequirements)

// использование unicode
xStream.toXML(dest).getBytes(StandardCharsets.UTF_8);


// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.amountOfChecks"));

// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.numberOfCheck"));

// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.averageOfChecks"));

// использование unicode
HttpEntity entity = new StringEntity(json, StandardCharsets.UTF_8);

// использование unicode
bundle = new PropertyResourceBundle(new InputStreamReader(stream, StandardCharsets.UTF_8));


/*
** Переменные и их значения
*/

// Было
int planningStartValue = 100;
... // Много кода
String result = planningStartValue / 2;

// Стало
... // Много кода
int planningStartValue = 100;
String result = planningStartValue / 2;

// Было
public boolean notify(StockDto stock, Boolean calculateBadges)
{
NotificationEntity notificationEntity = new NotificationEntity();
						notificationEntity.setRetailerCode(stock.getRetailer().getCode());
						notificationEntity.setIsDebug(VersionUtils.getIsDebug());
... // Много кода
notificationSender.send(KeyConfig.KEY_COMMAN_STOCK.getTitle(), KeyConfig.KEY_COMMAN_STOCK.getTitle(), new Gson().toJson(notificationEntity));
}

// Стало
public boolean notify(StockDto stock, Boolean calculateBadges)
{
... // Много кода
NotificationEntity notificationEntity = new NotificationEntity();
						notificationEntity.setRetailerCode(stock.getRetailer().getCode());
						notificationEntity.setIsDebug(VersionUtils.getIsDebug());
notificationSender.send(KeyConfig.KEY_COMMAN_STOCK.getTitle(), KeyConfig.KEY_COMMAN_STOCK.getTitle(), new Gson().toJson(notificationEntity));
notificationSender = null;
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
		JSONObject psItem;
		... // Много кода
		psItem = (JSONObject)jsonTreeElementArray.get(j);
        								String key = psItem.keys().next();
        								Object value = psItem.get(key);
        ... // Много кода
}

// Стало
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
        ... // Много кода
		JSONObject psItem;
		psItem = (JSONObject)jsonTreeElementArray.get(j);
        								String key = psItem.keys().next();
        								Object value = psItem.get(key);
        psItem = null;
}

// Было
int plansSize = 0;
while (plansSize < 10)
{
    ... // Много кода
    plansSize++;
}

// Стало
int plansSize = 0;
for (int i=0; i < 10; i++)
{
    ... // Много кода
    plansSize++;
}

// Было
int resultListSize = 0;
while (true)
{
    ... // Много кода
    if (resultListSize >= 10)
        break;
}

// Стало
for (int i=0; i < 10; i++)
{
    ... // Много кода
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values`");
     ... // Много кода

}

// Стало
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values`");
     ... // Много кода
    sqlConditions = null;
}

// Было
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
    Map<String, List<String>> timeIntervalListMap = new HashMap<>();
     ... // Много кода
}

// Стало
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
    Map<String, List<String>> timeIntervalListMap = new HashMap<>();
     ... // Много кода
     timeIntervalListMap = null;
}

// Было
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
	String lastQuarter = "";
	... //  Много кода
}

// Cтало
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
	String lastQuarter = "";
	... //  Много кода
	lastQuarter = null;
}

// Было
public void executeClastering(RetailerDto retailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	ClusteringMechanism clustering = new ClusteringMechanism();
	Map<List<Long>, List<Integer>> resultTagCardMap;
	... //  Много кода
	resultTagCardMap = clustering.getClasterResults(retailer, getRepository().getTagStatisticByRetailer(retailer, analysisScenario, rank), analysisScenario);
}

// Стало
public void executeClastering(RetailerDto retailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... //  Много кода
	ClusteringMechanism clustering = new ClusteringMechanism();
    Map<List<Long>, List<Integer>> resultTagCardMap;
	resultTagCardMap = clustering.getClasterResults(retailer, getRepository().getTagStatisticByRetailer(retailer, analysisScenario, rank), analysisScenario);
}

// Было
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	List<List<Long>> resultClasterCards = new ArrayList<>();
	... //  Много кода
}

// Стало
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	List<List<Long>> resultClasterCards = new ArrayList<>();
	... //  Много кода
	resultClasterCards = null;
}

// Было
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... // Много кода
	KMeansParams.Builder builder = new KMeansParams.Builder();
	... // Много кода
}

// Стало
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... // Много кода
	KMeansParams.Builder builder = new KMeansParams.Builder();
	builder = null;
}

// Было
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    double minSup = retailer.getSupportCoefficient().doubleValue();
    ... // Много кода
    for(int i = 0; i < this.itemsets.size(); i++)
    						if((count[i] / (double)(this.numTransactions)) >= this.minSup)
    					... // Много кода
}

// Стало
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    ... // Много кода
    double minSup = retailer.getSupportCoefficient().doubleValue();
    for(int i = 0; i < this.itemsets.size(); i++)
    						if((count[i] / (double)(this.numTransactions)) >= this.minSup)
    					... // Много кода
}

// Было
 public static List<Integer> getCategoryIntersections(List<Integer> goodCategoryList, EntityManager em, RetailerDto retailer)
 {
 	ArrayList<ArrayList<Integer>> tuplelist = new ArrayList<>();
 	... // Много кода
 }

 // Стало
 public static List<Integer> getCategoryIntersections(List<Integer> goodCategoryList, EntityManager em, RetailerDto retailer)
 {
 	ArrayList<ArrayList<Integer>> tuplelist = new ArrayList<>();
 	... // Много кода
 	tuplelist = null;
 }

// Было
private void calculateFrequentItemsets(RetailerDto retailer, EntityManager em)
{
    List<int[]> frequentCandidates = new ArrayList<int[]>(); // the frequent candidates for the current itemset.
    ... // Много кода
}

// Стало
private void calculateFrequentItemsets(RetailerDto retailer, EntityManager em)
{
    List<int[]> frequentCandidates = new ArrayList<int[]>(); // the frequent candidates for the current itemset.
    ... // Много кода
    frequentCandidates = null;
}


// Было
private void createNewItemsetsFromPreviousOnes()
{
    int currentSizeOfItemsets = this.itemsets.get(0).length;
    ... // Много кода
    int[] newCand = new int[currentSizeOfItemsets + 1];
    ... // Много кода
}

// Стало
private void createNewItemsetsFromPreviousOnes()
{
    ... // Много кода
    int currentSizeOfItemsets = this.itemsets.get(0).length;
    int[] newCand = new int[currentSizeOfItemsets + 1];
    ... // Много кода
    currentSizeOfItemsets = null;
    newCant = null;
}


/*
** Время жизни переменных
*/

// Было
Session session = (Session)em.getDelegate();

private void clearTuples(RetailerDto retailer, EntityManager em)
{
		session.doWork(new Work()
		{
				@Override
				public void execute(Connection connection) throws SQLException
				{
						String tuples = String.format(
							"DELETE FROM `apriori.tuples.categories` WHERE Retailer = %s;",
							retailer.getRecID());
						try (PreparedStatement pStmt = connection.prepareStatement(tuples))
						{
								pStmt.execute();
						}
				}
		});
}

// Стало. Сделал переменную session локальной
private void clearTuples(RetailerDto retailer, EntityManager em)
{
        Session session = (Session)em.getDelegate();
		session.doWork(new Work()
		{
				@Override
				public void execute(Connection connection) throws SQLException
				{
						String tuples = String.format(
							"DELETE FROM `apriori.tuples.categories` WHERE Retailer = %s;",
							retailer.getRecID());
						try (PreparedStatement pStmt = connection.prepareStatement(tuples))
						{
								pStmt.execute();
						}
				}
		});
}

// Было
private int numItems = 0;

public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
	while(t.hasMoreTokens())
    {
        int x = Integer.parseInt(t.nextToken());
        if(x + 1 > this.numItems)
             this.numItems = x + 1;
    }
    ...	// Много кода
}

// Стало. Сделал переменную numItems локальной
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    int numItems = 0;
	while(t.hasMoreTokens())
    {
        int x = Integer.parseInt(t.nextToken());
        if(x + 1 > this.numItems)
             this.numItems = x + 1;
    }
    ...	// Много кода
}

// Было
private RetailerDto retailer = DataServiceFactory.intance().getRetailersService().getAll().get(0);

@Override
protected void doWork()
{
	List<ProcedureStartParametersDto> procedureStartParameterList = DataServiceFactory.intance().getProcedureStartParametersDataService().getByRetailer(retailer);
    ...	// Много кода
}

// Стало. Сделал переменную retailer локальной
@Override
protected void doWork()
{
     RetailerDto retailer = DataServiceFactory.intance().getRetailersService().getAll().get(0);
	List<ProcedureStartParametersDto> procedureStartParameterList = DataServiceFactory.intance().getProcedureStartParametersDataService().getByRetailer(retailer);
    ...	// Много кода
}

// Было
private Date periodEndDate = DateUtils.subDay(DateUtils.now(), 1);

@Override
protected void doWork()
{
	DataServiceFactory.intance().getCardsService().callAnalysisRecalculation(periodStartDate, periodEndDate, Settings.instance().getIndicatorPeriod());
}

// Стало. Сделал переменную periodEndDate локальой
@Override
protected void doWork()
{
    Date periodEndDate = DateUtils.subDay(DateUtils.now(), 1);
	DataServiceFactory.intance().getCardsService().callAnalysisRecalculation(periodStartDate, periodEndDate, Settings.instance().getIndicatorPeriod());
}

// Было
private ProcedureStartParametersDto procedureParameters = procedureStartParameterList.get(0);
for(RetailerDto retailer : DataServiceFactory.intance().getRetailersService().getAll())
{
    ... // много кода
	procedureParameters.setLastRfmCompletedTime(DateUtils.now());
}

// Стало. Сделал переменную procedureParameters локальной
for(RetailerDto retailer : DataServiceFactory.intance().getRetailersService().getAll())
{
    ... // много кода
    ProcedureStartParametersDto procedureParameters = procedureStartParameterList.get(0);
	procedureParameters.setLastRfmCompletedTime(DateUtils.now());
}

// Было
private StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values` a INNER JOIN `analytics.plansandforecast.errors` er ON a.RecID = er.Plan");

for(int i = 0; i < jsonArray.length(); i++)
{
	    ... // много кода
	    List<String> errors = DataServiceFactory.intance().getPlanForecastValuesDataService().getErrorMessages(sqlConditions.toString());
}

// Стало. Сделал переменную sqlConditions локальной
for(int i = 0; i < jsonArray.length(); i++)
{
	    ... // много кода
	    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values` a INNER JOIN `analytics.plansandforecast.errors` er ON a.RecID = er.Plan");
	    List<String> errors = DataServiceFactory.intance().getPlanForecastValuesDataService().getErrorMessages(sqlConditions.toString());
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
	JSONObject psItem;
	for(int j = jsonTreeElementArray.length() - 1; j >= 0; j--)
    {
        psItem = (JSONObject)jsonTreeElementArray.get(j);
        String key = psItem.keys().next();
        Object value = psItem.get(key);
        ... // много кода
    }
}

// Стало. Сделал переменную psItem локальной
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
	for(int j = jsonTreeElementArray.length() - 1; j >= 0; j--)
    {
        JSONObject psItem = (JSONObject)jsonTreeElementArray.get(j);
        String key = psItem.keys().next();
        Object value = psItem.get(key);
        ... // много кода
    }
}

// Было
private String targetSection = SectionEnum.valueOf(section).name().toLowerCase();

private Boolean canUserRead(String section, UserDto user)
{
    boolean userAccessRights = false;
    List<PrivilegeSectionAccessDto> filteredPrivilegeSectionList = privilegeSectionAccessList.stream()
                                        .filter(o -> o.getSection().name().toLowerCase().equals(targetSection) || user.isPermissions(PrivilegeEnum.Administrator))
                                        .filter(o -> o.getRetailer().getRecID().equals(retailerDto.getRecID())).collect(Collectors.toList());
    ... // Много кода
}

// Стало. Сделал переменную targetSection локальной
private Boolean canUserRead(String section, UserDto user)
{
    String targetSection = SectionEnum.valueOf(section).name().toLowerCase();
    boolean userAccessRights = false;
    List<PrivilegeSectionAccessDto> filteredPrivilegeSectionList = privilegeSectionAccessList.stream()
                                        .filter(o -> o.getSection().name().toLowerCase().equals(targetSection) || user.isPermissions(PrivilegeEnum.Administrator))
                                        .filter(o -> o.getRetailer().getRecID().equals(retailerDto.getRecID())).collect(Collectors.toList());
    ... // Много кода
}

// Было
private String targetScheduler = SchedulerEnum.valueOf(schedulerName).name().toLowerCase();

private Boolean canRetailerRead(String schedulerName, RetailerDto retailer)
{
    boolean accessRights = false;
    if (schedulerAccessDtoList.stream()
                         .filter(o -> o.getScheduler().name().toLowerCase().equals(targetScheduler))
                         .anyMatch(o -> o.getIsActive().equals(true)))
                 {
                     accessRights = true;
                 }
    ... // Много кода
}

// Стало. Сделал переменную targetScheduler локальной
private Boolean canRetailerRead(String schedulerName, RetailerDto retailer)
{
    String targetScheduler = SchedulerEnum.valueOf(schedulerName).name().toLowerCase();
    boolean accessRights = false;
    if (schedulerAccessDtoList.stream()
                         .filter(o -> o.getScheduler().name().toLowerCase().equals(targetScheduler))
                         .anyMatch(o -> o.getIsActive().equals(true)))
                 {
                     accessRights = true;
                 }
    ... // Много кода
}

// Было
private List<BonusTypeDto> bonusTypeDtoList = DataServiceFactory.intance().getBonusTypeDataService().getAll();

private List<BonusTypeDto> initBonusTypes()
{
	bonusTypeDtoList.add(0, null);
	return bonusTypeDtoList;
}

// Стало. Сделал список bonusTypeDtoList локальным
private List<BonusTypeDto> initBonusTypes()
{
    List<BonusTypeDto> bonusTypeDtoList = DataServiceFactory.intance().getBonusTypeDataService().getAll();
	bonusTypeDtoList.add(0, null);
	return bonusTypeDtoList;
}

// Было
private List<SelectItem> result = new ArrayList<SelectItem>();

public List<SelectItem> getAllStockTypes()
{
	for(StockTypeEnum type : StockTypeEnum.values())
	{
	    type.setTypes(Localization.loadEnumString(type.getClass().getName(), type.name()));
	    result.add(new SelectItem(type, type.getTypes()));
	}
	return result;
}

// Стало. Сделал список result локальным
public List<SelectItem> getAllStockTypes()
{
    List<SelectItem> result = new ArrayList<SelectItem>();
	for(StockTypeEnum type : StockTypeEnum.values())
	{
	    type.setTypes(Localization.loadEnumString(type.getClass().getName(), type.name()));
	    result.add(new SelectItem(type, type.getTypes()));
	}
	return result;
}

// Было
private SelectItem[] result = new SelectItem[StockPersonalTypeEnum.values().length];

public SelectItem[] getPersonalTypes()
{
	int i = 0;
	for(StockPersonalTypeEnum item : StockPersonalTypeEnum.values())
	{
	    item.setTitle(Localization.loadEnumString(item.getClass().getName(), item.name()));
		if(item.name().equals(StockPersonalTypeEnum.Auditory.name()))
			result[i] = new SelectItem(item, item.getTitle(), null, !SectionPermissionsInitializer.getInstance().canRead("Audiences", SessionInfo.getInstance().getUser()));
		else
			result[i] = new SelectItem(item, item.getTitle());
		i++;
	}
	return result;
}

// Стало. Сделал список result локальным
public SelectItem[] getPersonalTypes()
{
    SelectItem[] result = new SelectItem[StockPersonalTypeEnum.values().length];
	int i = 0;
	for(StockPersonalTypeEnum item : StockPersonalTypeEnum.values())
	{
	    item.setTitle(Localization.loadEnumString(item.getClass().getName(), item.name()));
		if(item.name().equals(StockPersonalTypeEnum.Auditory.name()))
			result[i] = new SelectItem(item, item.getTitle(), null, !SectionPermissionsInitializer.getInstance().canRead("Audiences", SessionInfo.getInstance().getUser()));
		else
			result[i] = new SelectItem(item, item.getTitle());
		i++;
	}
	return result;
}

// Было
private StockDto stock = this.getEntity();

public String exportStockManually() throws FacesPortalException
{
	if(stock.getAuditory() != null && stock.getAuditory().getType().equals(AuditoryTypeEnum.Static) || stock.getBuyers() != null && !stock.getBuyers().isEmpty())
    	log.trace(String.format("Зафиксированно '%d' покупателей по данной акции", stock.getBuyers().size()));
    else
        stock.getBuyers().addAll(new AuditoryOperatorFactory().fixBuyers(stock, this.stockPersonalType, this.getCriteriaWrapper() == null? null: this.getCriteriaWrapper().getCriteria()));
    DataServiceFactory.intance().getStocksExportDataService().export(stock);
    stock.setActualExportDate(new Date());
    return this.save();
}

// Стало. Сделал переменную stock локальной
public String exportStockManually() throws FacesPortalException
{
    StockDto stock = this.getEntity();
	if(stock.getAuditory() != null && stock.getAuditory().getType().equals(AuditoryTypeEnum.Static) || stock.getBuyers() != null && !stock.getBuyers().isEmpty())
    	log.trace(String.format("Зафиксированно '%d' покупателей по данной акции", stock.getBuyers().size()));
    else
        stock.getBuyers().addAll(new AuditoryOperatorFactory().fixBuyers(stock, this.stockPersonalType, this.getCriteriaWrapper() == null? null: this.getCriteriaWrapper().getCriteria()));
    DataServiceFactory.intance().getStocksExportDataService().export(stock);
    stock.setActualExportDate(new Date());
    return this.save();
}

// Было
EntityManager em = DataServiceFactory.intance().getShopsService().getEm();

public DualListModel<ShopItem> initShopTypeList()
{
				... // Много кода
				Query query = em.createNativeQuery(sql);
				... // Много кода
}

// Стало. Сделал переменную em локальной
public DualListModel<ShopItem> initShopTypeList()
{
				EntityManager em = DataServiceFactory.intance().getShopsService().getEm();
				... // Много кода
				Query query = em.createNativeQuery(sql);
				... // Много кода
}

// Было
private String sqlTimeConditions = getTimeParametrList(request);

private void processRequest(HttpServletRequest request, HttpServletResponse response) throws Exception
{
	if(StringUtils.isRealyEmpty(sqlTimeConditions) && StringUtils.isRealyEmpty(sqlShopsConditions.keySet().toArray()[0].toString()) && StringUtils.isRealyEmpty(sqlShopsConditions.values().toArray()[0].toString()))
    {
        ... // Много кода
    }
}

// Стало. Сделал переменную sqlTimeConditions локальной
private void processRequest(HttpServletRequest request, HttpServletResponse response) throws Exception
{
    String sqlTimeConditions = getTimeParametrList(request);
	if(StringUtils.isRealyEmpty(sqlTimeConditions) && StringUtils.isRealyEmpty(sqlShopsConditions.keySet().toArray()[0].toString()) && StringUtils.isRealyEmpty(sqlShopsConditions.values().toArray()[0].toString()))
    {
        ... // Много кода
    }
}

/*
** Время связывания переменных
*/
// Использовал константу для связывания. Значение этой константы обозначает название параметра рест метода, который используется во многих местах.
// Если в дальнейшем потребуется изменить название параметра метода, то сделать это необходимо будет лишь в одном месте
public class BuyersRESTService extends BaseRestORMService<BuyerJSON, BuyerDto>
{
	public static final String PasswordParamName = "password";

	@POST
	@Path("/register/virtualNewLogic")
	@AccessAll
	public BuyerJSON registrationVirtual(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(PasswordParamName) String password,
			@QueryParam(DeviceParamName) String gmcid,
			@CheckBuyer @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID) throws Exception
	{
		return internalRegistrationVirtualWithBuyer(retailer, password, gmcid, buyerID);
	}

	@GET
    @AccessAll
    @Path("/loginAfterRestore")
    public BuyerJSON loginAfterRestore(
        	@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
    		@NonNull @QueryParam(LoginParamName) String cardNumber,
    		@NonNull @QueryParam(PasswordParamName) String password,
    		@NonNull @QueryParam(BaseRestORMService.RequestCodeParamName) String code,
    		@QueryParam(DeviceParamName) String deviceID) throws Exception
    {
    	return interalLoginAfterRestore(retailer, cardNumber, password, code, deviceID);
    }

    @GET
    @AccessAll
    @Path("/loginByPhoneNumberAndPassword")
    public BuyerJSON loginByPhoneNumberAndPassword(
            			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
            			@QueryParam(BaseRestORMService.PhoneNumberName) String phone,
            			@NonNull @QueryParam(PasswordParamName) String password) throws Exception
    {
    	return internalLoginByPhoneAndPassword(checkRetailer(retailer), phone, password);
    }
}

// BuyerDto buyer - связывание выполняется во время выполнения программы. Значение, которым инициализируется buyer зависит от входящих параметров метода.
private BuyerDto buyer;

private BuyerJSON returnVerifyNewPhone(
			String retailer,
			String phoneNew,
			String phoneOld,
			String code,
			Long buyerID) throws Exception
{
	checkRetailer(retailer);
	if(phoneOld.equals(""))
		phoneOld = phoneNew;
	if(buyerID != null)
	    buyer = DataServiceFactory.intance().getBuyersService().getByPhoneNumberAndDisposableCode(phoneOld, code, buyerID);
	else
		buyer = DataServiceFactory.intance().getBuyersService().getByPhoneNumberAndDisposableCode(phoneOld, code);
	if(buyer == null)
		throw new ShopperRestException(String.format("Некорректный номер телефона '%s' или проверочный код '%s'", phoneOld, code), ShopperHttpResponseCodes.INVALID_PHONE_NUMBER_OR_CODE);
	buyer.setPhone(phoneNew);
	buyer.setVerified(new Date());
	buyer.setInternalEditDateTime(new Date());
	buyer = DataServiceFactory.intance().getBuyersService().update(buyer);
	DataServiceFactory.intance().getBuyersDisposableService().getRepository().deleteByBuyer(buyer, BuyersDisposablePasswordTypeEnum.Verify);
	return RestServiceUtils.getBuyerJSON(buyer);
}

// Для stockPersonalType используем максимально ранее связывание, инициализируя его значением по умолчанию.
/**
  * Тип аудитории, на которую распространяется акция
**/
@Getter
@Setter
private StockPersonalTypeEnum stockPersonalType = StockPersonalTypeEnum.Common;

public TreeCriteriaWrapper getCriteriaWrapper()
{
	switch(this.stockPersonalType)
	{
    	case Auditory:
	    	if(this.getEntity().getAuditory() != null)
				if(AuditoryTypeEnum.Calculated.equals(this.getEntity().getAuditory().getType()))
						this.criteriaWrapper = new TreeCriteriaWrapper(this.getEntity().getAuditory().getCriteria(), this);
			break;
		case Criteria:
			if(this.criteriaWrapper == null)
				this.criteriaWrapper = new TreeCriteriaWrapper(new Criteria(), this);
					break;
		case Common:
		case All:
		case SelectedBuyers:
			break;
		}
	return this.criteriaWrapper;
}
