/*
** Баги в наименовании
*/
// сеттер для поля isNeedToCalculateAllShops
needToCalculateAllShops - setNeedToCalculateAllShops

// метод, вызываемый при изменении вкладки
changeTab - onChangeTab

// Обновить статус товара
statusDelivered - updateOrderStatus


/*
** Рефакторинг имен переменных
*/
sqlTimeConditions - timeConditions

sqlShopsConditions - shopConditions

sqlConditionList - conditions

sqlBrandConditionList - brandConditions

tabId - planningTabId

allDetailingObjects - detailingObjectList

availableYears - availableYearList

filterYears - filterYearQueue

sizesOfPlanValues - planValueListSize

name - buyerName

age - buyerAge

order - receiptOrder

checkedSignificantBrandList - checkedSignificantBrands

getIsNeedToShowAddDialog - isNeedToShowDialog

/*
** Имена переменных
*/

// 7.1
processCompleted - isProcessCompleted

isNeedToUpdate - doNeedUpdate

isCalculatingError - hasCalculatingError

isMessageSendingStopped - doMailingStopped

queryRunning - isQueryRunning

// 7.2
processFinished - isProcessDone

isElementExists - isElementFound

// 7.3

i - element

// 7.4
isMailingStarted, isMailingFinished - isMailingBegin, isMailingEnd

// 7.5
tmpSelectItemChecks - selectItemChecks
tmpStart - dateStart
tmpFinish - dateFinish

/*
** Имена, которых следует избегать
*/

allChannelsForRetailer - allChannels

filteredByEmailAndSmsChannelList - emailSmsChannels

addChannelsNotification - allowAllChannelsToBuyer

channelsDtoDualListModel - channelDualList

consumerList - consumers

goodsValue - goodsCount

buyerList1 - buyerOriginalList

buyerList2 - buyerProcessedList

retailerObject - retailer

guaranteedMessageDeliveryScheduler - msgDeliveryScheduler

max - maxSumOfCheck

value - checkValue

/*
** Имена классов
*/

// 3.1
CreatePage - PageConstructor

RuleManager - RuleController

EntityInfo - EntityPayload

CheckDeserializeProcessor - CheckDeserializer

CardDeserializeProcessor - CardDeserializer

// 3.2

initCheckFile - initDocument (реализация абстрактного метода)

initCardFile - initDocument (реализация абстрактного метода)

applyDiscountMechanic - applyMechanic (реализация абстрактного метода)

applyBonusMechanic - applyMechanic (реализация абстрактного метода)

bonusRuleManager - ruleManager

discountRuleManager - ruleManager

pull - pullResult

/*
** Имена функций/методов
*/

sendMessageAndCheckDelivery - sendMessage() - checkDelivery() - разделил один метод на два, убрав побочные действия метода

runSmsExecutorAndSaveToFile - runSmsExecutor() - saveResultToFile() - разделил один метод на два, убрав побочные действия метода

getViberJSONObjectAndSendMessage - getViberJSON() - sendMessage() - разделил один метод на два, убрав побочные действия метода

editName - setName - переименовал метод для изменения имени

reloadPage() - reload() - поправил название метода, т.к метод reload относится к классу Page

sendMessage() - send() - поправил название метода, т.к метод send относится к классу Message

taxiOrderToComplete() - completeTaxiOrder() - поправил название метода

lastMessageToFind() - findLastMessage() - поправил название метода

pageReload() - reloadPage() - поправил название метода

Element element = prevElement.add(20) - int element = prevElement.setIndex(20) - переименовал методв add в setIndex

Date date = prevDate.add(20) - Date date = prevDate.addMinutes(20);

entityToUpdate() - updateEntity() - поправил название метода

/*
** ООП и интерфейсы
*/

// 3.1
//  Метод-фабрика DataServiceFactory
    public static synchronized DataServiceFactory getInstance()
    		{
    				if(instance == null)
    						synchronized(DataServiceFactory.class)
    						{
    								try
    								{
    										if(instance == null)
    										{
    												InitialContext context = new InitialContext();
    												instance = (DataServiceFactory)context.lookup("java:module/DataServiceFactory");
    										}
    								}
    								catch(Exception e)
    								{
    										ExceptionHandler.handle(e);
    								}
    						}
    				return instance;
    		}

// Метод-фабрика AuditoryOperatorFactory
AuditoryOperatorFactory auditoryOperatorFactory = new AuditoryOperatorFactory(stock) - AuditoryOperatorFactory.fromStock(stock);

// Метод-фабрика BonusOperatorFactory
BonusOperatorFactory bonusOperatorFactory = new BonusOperatorFactory(bonus) - BonusOperatorFactory.fromBonus(bonus);

// 3.2
IDiscountMechanic - DiscountMechanic
IRuleManager - RuleManager
IBonusMechanic - BonusMechanic

/*
** Константы
*/

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String NumberParamName = "number";
public CardJSON register(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(NumberParamName) String number) throws Exception

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String CardIDParamName = "cardID";

public CardJSON getCard(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(CardIDParamName) Long cardID)
	{
		return getJSON(DataServiceFactory.intance().getCardsService().findById(cardID));
	}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String LoginParamName = "login";

	public BuyerJSON loginByHashPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(LoginParamName) String cardNumber,
			@NonNull String password,
			@QueryParam(DeviceParamName) String deviceID) throws Exception
		{
				return internalLogin(retailer, cardNumber, password, deviceID);
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
public static final String PasswordParamName = "password";

public BuyerJSON loginByPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(LoginParamName) String cardNumber,
			@NonNull @QueryParam(PasswordParamName) String password,
			@QueryParam(DeviceParamName) String deviceID,
			@QueryParam(BuyerIDParamName) Long buyerID,
			@QueryParam(BaseRestORMService.isNewLogic) Boolean... newLogic) throws Exception
		{
				if(newLogic.length > 0)
						return internalLogin(retailer, cardNumber, password, deviceID, buyerID);
				else
						return internalLogin(retailer, cardNumber, password, deviceID);
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String CardNumberParamName = "cardNumber";

	@POST
		@Path("/register/material4")
		@AccessAll
		public BuyerJSON registrationMaterialByHashPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailerCode,
			@NotNull @QueryParam(BaseRestORMService.BuyerParamName) BuyerJSON buyer,
			@NonNull @QueryParam(CardNumberParamName) String login,
			@NonNull String password,
			@QueryParam(DeviceParamName) String gmcid) throws Exception
		{
				return internalRegisterMaterial(retailerCode, login, password, gmcid, (o) -> createFromJSON(buyer));
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String DeviceCheckParamName = "deviceCheck";

//Скидка по умолчанию
private static final Double DefaultDiscount = 0d;

// Формат даты
private static final DateFormat SimpleDateFormat = new SimpleDateFormat("yyyyMMdd");

// Формат даты
private static final DateFormat BirthDayDateFormat = new SimpleDateFormat("MMdd");

// Формат даты
private static final SimpleDateFormat GUIDateTimeFormat = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");

// Формат даты
private static final SimpleDateFormat JQPlotDateTimeFormat = new SimpleDateFormat("MM.dd.yyyy HH:mm");

// Формат даты
private static final DateFormat FilenameDateTimeFormat = new SimpleDateFormat("ddMMyyyy HHmm");



/*
** Типы данных
*/

// использование unicode
String json = new String(body, StandardCharsets.UTF_8);

// Добавлена проверка на 0
if (checkItem.getQuantity() <> 0)
    checkItem.setPrice(checkItem.getSum().divide(checkItem.getQuantity()));

// Добавлена локализация
CategoryAxis axisX = new CategoryAxis(Localization.loadString("IndicatorController.categoryAxis.label.months"));

// Добавлена локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("IndicatorController.lineChartModel.axisY.label.checkNumber"));

// Добавлена локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("IndicatorController.lineChartModel.axisY.label.buyerNumber"));


// Дополнительные булевые переменные
// Было
if(MechanicManager.getInstance().getDiscountMechanics()
									.get(buyerDiscountStocks.get(i).getStockDiscountMechanic() != null? buyerDiscountStocks.get(i).getStockDiscountMechanic(): StockDiscountMechanicEnum.DiscountOnGood)
									.isCheckItemFitsRequirements(processedCheck, processedCheckItem, buyerDiscountStocks.get(i)))

// Стало

Boolean isCheckFitsRequirements = MechanicManager.getInstance().getDiscountMechanics()
									.get(buyerDiscountStocks.get(i).getStockDiscountMechanic() != null? buyerDiscountStocks.get(i).getStockDiscountMechanic(): StockDiscountMechanicEnum.DiscountOnGood)
									.isCheckItemFitsRequirements(processedCheck, processedCheckItem, buyerDiscountStocks.get(i))
									if (isCheckFitsRequirements)

// использование unicode
xStream.toXML(dest).getBytes(StandardCharsets.UTF_8);


// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.amountOfChecks"));

// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.numberOfCheck"));

// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.averageOfChecks"));

// использование unicode
HttpEntity entity = new StringEntity(json, StandardCharsets.UTF_8);

// использование unicode
bundle = new PropertyResourceBundle(new InputStreamReader(stream, StandardCharsets.UTF_8));


/*
** Переменные и их значения
*/

// Было
int planningStartValue = 100;
... // Много кода
String result = planningStartValue / 2;

// Стало
... // Много кода
int planningStartValue = 100;
String result = planningStartValue / 2;

// Было
public boolean notify(StockDto stock, Boolean calculateBadges)
{
NotificationEntity notificationEntity = new NotificationEntity();
						notificationEntity.setRetailerCode(stock.getRetailer().getCode());
						notificationEntity.setIsDebug(VersionUtils.getIsDebug());
... // Много кода
notificationSender.send(KeyConfig.KEY_COMMAN_STOCK.getTitle(), KeyConfig.KEY_COMMAN_STOCK.getTitle(), new Gson().toJson(notificationEntity));
}

// Стало
public boolean notify(StockDto stock, Boolean calculateBadges)
{
... // Много кода
NotificationEntity notificationEntity = new NotificationEntity();
						notificationEntity.setRetailerCode(stock.getRetailer().getCode());
						notificationEntity.setIsDebug(VersionUtils.getIsDebug());
notificationSender.send(KeyConfig.KEY_COMMAN_STOCK.getTitle(), KeyConfig.KEY_COMMAN_STOCK.getTitle(), new Gson().toJson(notificationEntity));
notificationSender = null;
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
		JSONObject psItem;
		... // Много кода
		psItem = (JSONObject)jsonTreeElementArray.get(j);
        								String key = psItem.keys().next();
        								Object value = psItem.get(key);
        ... // Много кода
}

// Стало
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
        ... // Много кода
		JSONObject psItem;
		psItem = (JSONObject)jsonTreeElementArray.get(j);
        								String key = psItem.keys().next();
        								Object value = psItem.get(key);
        psItem = null;
}

// Было
int plansSize = 0;
while (plansSize < 10)
{
    ... // Много кода
    plansSize++;
}

// Стало
int plansSize = 0;
for (int i=0; i < 10; i++)
{
    ... // Много кода
    plansSize++;
}

// Было
int resultListSize = 0;
while (true)
{
    ... // Много кода
    if (resultListSize >= 10)
        break;
}

// Стало
for (int i=0; i < 10; i++)
{
    ... // Много кода
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values`");
     ... // Много кода

}

// Стало
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values`");
     ... // Много кода
    sqlConditions = null;
}

// Было
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
    Map<String, List<String>> timeIntervalListMap = new HashMap<>();
     ... // Много кода
}

// Стало
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
    Map<String, List<String>> timeIntervalListMap = new HashMap<>();
     ... // Много кода
     timeIntervalListMap = null;
}

// Было
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
	String lastQuarter = "";
	... //  Много кода
}

// Cтало
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
	String lastQuarter = "";
	... //  Много кода
	lastQuarter = null;
}

// Было
public void executeClastering(RetailerDto retailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	ClusteringMechanism clustering = new ClusteringMechanism();
	Map<List<Long>, List<Integer>> resultTagCardMap;
	... //  Много кода
	resultTagCardMap = clustering.getClasterResults(retailer, getRepository().getTagStatisticByRetailer(retailer, analysisScenario, rank), analysisScenario);
}

// Стало
public void executeClastering(RetailerDto retailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... //  Много кода
	ClusteringMechanism clustering = new ClusteringMechanism();
    Map<List<Long>, List<Integer>> resultTagCardMap;
	resultTagCardMap = clustering.getClasterResults(retailer, getRepository().getTagStatisticByRetailer(retailer, analysisScenario, rank), analysisScenario);
}

// Было
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	List<List<Long>> resultClasterCards = new ArrayList<>();
	... //  Много кода
}

// Стало
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	List<List<Long>> resultClasterCards = new ArrayList<>();
	... //  Много кода
	resultClasterCards = null;
}

// Было
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... // Много кода
	KMeansParams.Builder builder = new KMeansParams.Builder();
	... // Много кода
}

// Стало
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... // Много кода
	KMeansParams.Builder builder = new KMeansParams.Builder();
	builder = null;
}

// Было
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    double minSup = retailer.getSupportCoefficient().doubleValue();
    ... // Много кода
    for(int i = 0; i < this.itemsets.size(); i++)
    						if((count[i] / (double)(this.numTransactions)) >= this.minSup)
    					... // Много кода
}

// Стало
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    ... // Много кода
    double minSup = retailer.getSupportCoefficient().doubleValue();
    for(int i = 0; i < this.itemsets.size(); i++)
    						if((count[i] / (double)(this.numTransactions)) >= this.minSup)
    					... // Много кода
}

// Было
 public static List<Integer> getCategoryIntersections(List<Integer> goodCategoryList, EntityManager em, RetailerDto retailer)
 {
 	ArrayList<ArrayList<Integer>> tuplelist = new ArrayList<>();
 	... // Много кода
 }

 // Стало
 public static List<Integer> getCategoryIntersections(List<Integer> goodCategoryList, EntityManager em, RetailerDto retailer)
 {
 	ArrayList<ArrayList<Integer>> tuplelist = new ArrayList<>();
 	... // Много кода
 	tuplelist = null;
 }

// Было
private void calculateFrequentItemsets(RetailerDto retailer, EntityManager em)
{
    List<int[]> frequentCandidates = new ArrayList<int[]>(); // the frequent candidates for the current itemset.
    ... // Много кода
}

// Стало
private void calculateFrequentItemsets(RetailerDto retailer, EntityManager em)
{
    List<int[]> frequentCandidates = new ArrayList<int[]>(); // the frequent candidates for the current itemset.
    ... // Много кода
    frequentCandidates = null;
}


// Было
private void createNewItemsetsFromPreviousOnes()
{
    int currentSizeOfItemsets = this.itemsets.get(0).length;
    ... // Много кода
    int[] newCand = new int[currentSizeOfItemsets + 1];
    ... // Много кода
}

// Стало
private void createNewItemsetsFromPreviousOnes()
{
    ... // Много кода
    int currentSizeOfItemsets = this.itemsets.get(0).length;
    int[] newCand = new int[currentSizeOfItemsets + 1];
    ... // Много кода
    currentSizeOfItemsets = null;
    newCant = null;
}


/*
** Время жизни переменных
*/

// Было
Session session = (Session)em.getDelegate();

private void clearTuples(RetailerDto retailer, EntityManager em)
{
		session.doWork(new Work()
		{
				@Override
				public void execute(Connection connection) throws SQLException
				{
						String tuples = String.format(
							"DELETE FROM `apriori.tuples.categories` WHERE Retailer = %s;",
							retailer.getRecID());
						try (PreparedStatement pStmt = connection.prepareStatement(tuples))
						{
								pStmt.execute();
						}
				}
		});
}

// Стало. Сделал переменную session локальной
private void clearTuples(RetailerDto retailer, EntityManager em)
{
        Session session = (Session)em.getDelegate();
		session.doWork(new Work()
		{
				@Override
				public void execute(Connection connection) throws SQLException
				{
						String tuples = String.format(
							"DELETE FROM `apriori.tuples.categories` WHERE Retailer = %s;",
							retailer.getRecID());
						try (PreparedStatement pStmt = connection.prepareStatement(tuples))
						{
								pStmt.execute();
						}
				}
		});
}

// Было
private int numItems = 0;

public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
	while(t.hasMoreTokens())
    {
        int x = Integer.parseInt(t.nextToken());
        if(x + 1 > this.numItems)
             this.numItems = x + 1;
    }
    ...	// Много кода
}

// Стало. Сделал переменную numItems локальной
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    int numItems = 0;
	while(t.hasMoreTokens())
    {
        int x = Integer.parseInt(t.nextToken());
        if(x + 1 > this.numItems)
             this.numItems = x + 1;
    }
    ...	// Много кода
}

// Было
private RetailerDto retailer = DataServiceFactory.intance().getRetailersService().getAll().get(0);

@Override
protected void doWork()
{
	List<ProcedureStartParametersDto> procedureStartParameterList = DataServiceFactory.intance().getProcedureStartParametersDataService().getByRetailer(retailer);
    ...	// Много кода
}

// Стало. Сделал переменную retailer локальной
@Override
protected void doWork()
{
     RetailerDto retailer = DataServiceFactory.intance().getRetailersService().getAll().get(0);
	List<ProcedureStartParametersDto> procedureStartParameterList = DataServiceFactory.intance().getProcedureStartParametersDataService().getByRetailer(retailer);
    ...	// Много кода
}

// Было
private Date periodEndDate = DateUtils.subDay(DateUtils.now(), 1);

@Override
protected void doWork()
{
	DataServiceFactory.intance().getCardsService().callAnalysisRecalculation(periodStartDate, periodEndDate, Settings.instance().getIndicatorPeriod());
}

// Стало. Сделал переменную periodEndDate локальой
@Override
protected void doWork()
{
    Date periodEndDate = DateUtils.subDay(DateUtils.now(), 1);
	DataServiceFactory.intance().getCardsService().callAnalysisRecalculation(periodStartDate, periodEndDate, Settings.instance().getIndicatorPeriod());
}

// Было
private ProcedureStartParametersDto procedureParameters = procedureStartParameterList.get(0);
for(RetailerDto retailer : DataServiceFactory.intance().getRetailersService().getAll())
{
    ... // много кода
	procedureParameters.setLastRfmCompletedTime(DateUtils.now());
}

// Стало. Сделал переменную procedureParameters локальной
for(RetailerDto retailer : DataServiceFactory.intance().getRetailersService().getAll())
{
    ... // много кода
    ProcedureStartParametersDto procedureParameters = procedureStartParameterList.get(0);
	procedureParameters.setLastRfmCompletedTime(DateUtils.now());
}

// Было
private StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values` a INNER JOIN `analytics.plansandforecast.errors` er ON a.RecID = er.Plan");

for(int i = 0; i < jsonArray.length(); i++)
{
	    ... // много кода
	    List<String> errors = DataServiceFactory.intance().getPlanForecastValuesDataService().getErrorMessages(sqlConditions.toString());
}

// Стало. Сделал переменную sqlConditions локальной
for(int i = 0; i < jsonArray.length(); i++)
{
	    ... // много кода
	    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values` a INNER JOIN `analytics.plansandforecast.errors` er ON a.RecID = er.Plan");
	    List<String> errors = DataServiceFactory.intance().getPlanForecastValuesDataService().getErrorMessages(sqlConditions.toString());
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
	JSONObject psItem;
	for(int j = jsonTreeElementArray.length() - 1; j >= 0; j--)
    {
        psItem = (JSONObject)jsonTreeElementArray.get(j);
        String key = psItem.keys().next();
        Object value = psItem.get(key);
        ... // много кода
    }
}

// Стало. Сделал переменную psItem локальной
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
	for(int j = jsonTreeElementArray.length() - 1; j >= 0; j--)
    {
        JSONObject psItem = (JSONObject)jsonTreeElementArray.get(j);
        String key = psItem.keys().next();
        Object value = psItem.get(key);
        ... // много кода
    }
}

// Было
private String targetSection = SectionEnum.valueOf(section).name().toLowerCase();

private Boolean canUserRead(String section, UserDto user)
{
    boolean userAccessRights = false;
    List<PrivilegeSectionAccessDto> filteredPrivilegeSectionList = privilegeSectionAccessList.stream()
                                        .filter(o -> o.getSection().name().toLowerCase().equals(targetSection) || user.isPermissions(PrivilegeEnum.Administrator))
                                        .filter(o -> o.getRetailer().getRecID().equals(retailerDto.getRecID())).collect(Collectors.toList());
    ... // Много кода
}

// Стало. Сделал переменную targetSection локальной
private Boolean canUserRead(String section, UserDto user)
{
    String targetSection = SectionEnum.valueOf(section).name().toLowerCase();
    boolean userAccessRights = false;
    List<PrivilegeSectionAccessDto> filteredPrivilegeSectionList = privilegeSectionAccessList.stream()
                                        .filter(o -> o.getSection().name().toLowerCase().equals(targetSection) || user.isPermissions(PrivilegeEnum.Administrator))
                                        .filter(o -> o.getRetailer().getRecID().equals(retailerDto.getRecID())).collect(Collectors.toList());
    ... // Много кода
}

// Было
private String targetScheduler = SchedulerEnum.valueOf(schedulerName).name().toLowerCase();

private Boolean canRetailerRead(String schedulerName, RetailerDto retailer)
{
    boolean accessRights = false;
    if (schedulerAccessDtoList.stream()
                         .filter(o -> o.getScheduler().name().toLowerCase().equals(targetScheduler))
                         .anyMatch(o -> o.getIsActive().equals(true)))
                 {
                     accessRights = true;
                 }
    ... // Много кода
}

// Стало. Сделал переменную targetScheduler локальной
private Boolean canRetailerRead(String schedulerName, RetailerDto retailer)
{
    String targetScheduler = SchedulerEnum.valueOf(schedulerName).name().toLowerCase();
    boolean accessRights = false;
    if (schedulerAccessDtoList.stream()
                         .filter(o -> o.getScheduler().name().toLowerCase().equals(targetScheduler))
                         .anyMatch(o -> o.getIsActive().equals(true)))
                 {
                     accessRights = true;
                 }
    ... // Много кода
}

// Было
private List<BonusTypeDto> bonusTypeDtoList = DataServiceFactory.intance().getBonusTypeDataService().getAll();

private List<BonusTypeDto> initBonusTypes()
{
	bonusTypeDtoList.add(0, null);
	return bonusTypeDtoList;
}

// Стало. Сделал список bonusTypeDtoList локальным
private List<BonusTypeDto> initBonusTypes()
{
    List<BonusTypeDto> bonusTypeDtoList = DataServiceFactory.intance().getBonusTypeDataService().getAll();
	bonusTypeDtoList.add(0, null);
	return bonusTypeDtoList;
}

// Было
private List<SelectItem> result = new ArrayList<SelectItem>();

public List<SelectItem> getAllStockTypes()
{
	for(StockTypeEnum type : StockTypeEnum.values())
	{
	    type.setTypes(Localization.loadEnumString(type.getClass().getName(), type.name()));
	    result.add(new SelectItem(type, type.getTypes()));
	}
	return result;
}

// Стало. Сделал список result локальным
public List<SelectItem> getAllStockTypes()
{
    List<SelectItem> result = new ArrayList<SelectItem>();
	for(StockTypeEnum type : StockTypeEnum.values())
	{
	    type.setTypes(Localization.loadEnumString(type.getClass().getName(), type.name()));
	    result.add(new SelectItem(type, type.getTypes()));
	}
	return result;
}

// Было
private SelectItem[] result = new SelectItem[StockPersonalTypeEnum.values().length];

public SelectItem[] getPersonalTypes()
{
	int i = 0;
	for(StockPersonalTypeEnum item : StockPersonalTypeEnum.values())
	{
	    item.setTitle(Localization.loadEnumString(item.getClass().getName(), item.name()));
		if(item.name().equals(StockPersonalTypeEnum.Auditory.name()))
			result[i] = new SelectItem(item, item.getTitle(), null, !SectionPermissionsInitializer.getInstance().canRead("Audiences", SessionInfo.getInstance().getUser()));
		else
			result[i] = new SelectItem(item, item.getTitle());
		i++;
	}
	return result;
}

// Стало. Сделал список result локальным
public SelectItem[] getPersonalTypes()
{
    SelectItem[] result = new SelectItem[StockPersonalTypeEnum.values().length];
	int i = 0;
	for(StockPersonalTypeEnum item : StockPersonalTypeEnum.values())
	{
	    item.setTitle(Localization.loadEnumString(item.getClass().getName(), item.name()));
		if(item.name().equals(StockPersonalTypeEnum.Auditory.name()))
			result[i] = new SelectItem(item, item.getTitle(), null, !SectionPermissionsInitializer.getInstance().canRead("Audiences", SessionInfo.getInstance().getUser()));
		else
			result[i] = new SelectItem(item, item.getTitle());
		i++;
	}
	return result;
}

// Было
private StockDto stock = this.getEntity();

public String exportStockManually() throws FacesPortalException
{
	if(stock.getAuditory() != null && stock.getAuditory().getType().equals(AuditoryTypeEnum.Static) || stock.getBuyers() != null && !stock.getBuyers().isEmpty())
    	log.trace(String.format("Зафиксированно '%d' покупателей по данной акции", stock.getBuyers().size()));
    else
        stock.getBuyers().addAll(new AuditoryOperatorFactory().fixBuyers(stock, this.stockPersonalType, this.getCriteriaWrapper() == null? null: this.getCriteriaWrapper().getCriteria()));
    DataServiceFactory.intance().getStocksExportDataService().export(stock);
    stock.setActualExportDate(new Date());
    return this.save();
}

// Стало. Сделал переменную stock локальной
public String exportStockManually() throws FacesPortalException
{
    StockDto stock = this.getEntity();
	if(stock.getAuditory() != null && stock.getAuditory().getType().equals(AuditoryTypeEnum.Static) || stock.getBuyers() != null && !stock.getBuyers().isEmpty())
    	log.trace(String.format("Зафиксированно '%d' покупателей по данной акции", stock.getBuyers().size()));
    else
        stock.getBuyers().addAll(new AuditoryOperatorFactory().fixBuyers(stock, this.stockPersonalType, this.getCriteriaWrapper() == null? null: this.getCriteriaWrapper().getCriteria()));
    DataServiceFactory.intance().getStocksExportDataService().export(stock);
    stock.setActualExportDate(new Date());
    return this.save();
}

// Было
EntityManager em = DataServiceFactory.intance().getShopsService().getEm();

public DualListModel<ShopItem> initShopTypeList()
{
				... // Много кода
				Query query = em.createNativeQuery(sql);
				... // Много кода
}

// Стало. Сделал переменную em локальной
public DualListModel<ShopItem> initShopTypeList()
{
				EntityManager em = DataServiceFactory.intance().getShopsService().getEm();
				... // Много кода
				Query query = em.createNativeQuery(sql);
				... // Много кода
}

// Было
private String sqlTimeConditions = getTimeParametrList(request);

private void processRequest(HttpServletRequest request, HttpServletResponse response) throws Exception
{
	if(StringUtils.isRealyEmpty(sqlTimeConditions) && StringUtils.isRealyEmpty(sqlShopsConditions.keySet().toArray()[0].toString()) && StringUtils.isRealyEmpty(sqlShopsConditions.values().toArray()[0].toString()))
    {
        ... // Много кода
    }
}

// Стало. Сделал переменную sqlTimeConditions локальной
private void processRequest(HttpServletRequest request, HttpServletResponse response) throws Exception
{
    String sqlTimeConditions = getTimeParametrList(request);
	if(StringUtils.isRealyEmpty(sqlTimeConditions) && StringUtils.isRealyEmpty(sqlShopsConditions.keySet().toArray()[0].toString()) && StringUtils.isRealyEmpty(sqlShopsConditions.values().toArray()[0].toString()))
    {
        ... // Много кода
    }
}

/*
** Время связывания переменных
*/
// Использовал константу для связывания. Значение этой константы обозначает название параметра рест метода, который используется во многих местах.
// Если в дальнейшем потребуется изменить название параметра метода, то сделать это необходимо будет лишь в одном месте
public class BuyersRESTService extends BaseRestORMService<BuyerJSON, BuyerDto>
{
	public static final String PasswordParamName = "password";

	@POST
	@Path("/register/virtualNewLogic")
	@AccessAll
	public BuyerJSON registrationVirtual(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(PasswordParamName) String password,
			@QueryParam(DeviceParamName) String gmcid,
			@CheckBuyer @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID) throws Exception
	{
		return internalRegistrationVirtualWithBuyer(retailer, password, gmcid, buyerID);
	}

	@GET
    @AccessAll
    @Path("/loginAfterRestore")
    public BuyerJSON loginAfterRestore(
        	@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
    		@NonNull @QueryParam(LoginParamName) String cardNumber,
    		@NonNull @QueryParam(PasswordParamName) String password,
    		@NonNull @QueryParam(BaseRestORMService.RequestCodeParamName) String code,
    		@QueryParam(DeviceParamName) String deviceID) throws Exception
    {
    	return interalLoginAfterRestore(retailer, cardNumber, password, code, deviceID);
    }

    @GET
    @AccessAll
    @Path("/loginByPhoneNumberAndPassword")
    public BuyerJSON loginByPhoneNumberAndPassword(
            			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
            			@QueryParam(BaseRestORMService.PhoneNumberName) String phone,
            			@NonNull @QueryParam(PasswordParamName) String password) throws Exception
    {
    	return internalLoginByPhoneAndPassword(checkRetailer(retailer), phone, password);
    }
}

// BuyerDto buyer - связывание выполняется во время выполнения программы. Значение, которым инициализируется buyer зависит от входящих параметров метода.
private BuyerDto buyer;

private BuyerJSON returnVerifyNewPhone(
			String retailer,
			String phoneNew,
			String phoneOld,
			String code,
			Long buyerID) throws Exception
{
	checkRetailer(retailer);
	if(phoneOld.equals(""))
		phoneOld = phoneNew;
	if(buyerID != null)
	    buyer = DataServiceFactory.intance().getBuyersService().getByPhoneNumberAndDisposableCode(phoneOld, code, buyerID);
	else
		buyer = DataServiceFactory.intance().getBuyersService().getByPhoneNumberAndDisposableCode(phoneOld, code);
	if(buyer == null)
		throw new ShopperRestException(String.format("Некорректный номер телефона '%s' или проверочный код '%s'", phoneOld, code), ShopperHttpResponseCodes.INVALID_PHONE_NUMBER_OR_CODE);
	buyer.setPhone(phoneNew);
	buyer.setVerified(new Date());
	buyer.setInternalEditDateTime(new Date());
	buyer = DataServiceFactory.intance().getBuyersService().update(buyer);
	DataServiceFactory.intance().getBuyersDisposableService().getRepository().deleteByBuyer(buyer, BuyersDisposablePasswordTypeEnum.Verify);
	return RestServiceUtils.getBuyerJSON(buyer);
}

// Для stockPersonalType используем максимально ранее связывание, инициализируя его значением по умолчанию.
/**
  * Тип аудитории, на которую распространяется акция
**/
@Getter
@Setter
private StockPersonalTypeEnum stockPersonalType = StockPersonalTypeEnum.Common;

public TreeCriteriaWrapper getCriteriaWrapper()
{
	switch(this.stockPersonalType)
	{
    	case Auditory:
	    	if(this.getEntity().getAuditory() != null)
				if(AuditoryTypeEnum.Calculated.equals(this.getEntity().getAuditory().getType()))
						this.criteriaWrapper = new TreeCriteriaWrapper(this.getEntity().getAuditory().getCriteria(), this);
			break;
		case Criteria:
			if(this.criteriaWrapper == null)
				this.criteriaWrapper = new TreeCriteriaWrapper(new Criteria(), this);
					break;
		case Common:
		case All:
		case SelectedBuyers:
			break;
		}
	return this.criteriaWrapper;
}

_____________________________________________________________________
/*
** Массивы
*/
// Было. Использовал доступ к массиву через индексы
public void onChangeBookMarkName(StockGoodBookmarkDto value)
{
	if(value == null)
		return;
	for(int i = 0; i < this.getEntity().getStockItems().size; i++)
		if(this.getEntity().getStockItems().get(i).getBookmark() != null && this.getEntity().getStockItems().get(i).getBookmark().getBookmarkPosition().equals(value.getBookmarkPosition()))
			this.getEntity().getStockItems().get(i).setBookmarkName(value.getName());
}

// Стало. Использовал цикл foreach для работы с элементами массива
public void onChangeBookMarkName(StockGoodBookmarkDto value)
{
	if(value == null)
		return;
	for(StockGoodDto good : this.getEntity().getStockItems())
		if(good.getBookmark() != null && good.getBookmark().getBookmarkPosition().equals(value.getBookmarkPosition()))
			good.setBookmarkName(value.getName());
}

// Было. Использовал массив для работы с группами магазинов
private DualListModel<ShopsGroupDto> initGroupsShopTypeList(){
			List<ShopsGroupDto> target = this.getEntity().getGroupsShops();
			List<ShopsGroupDto> allShopsGroupDtoSource = DataServiceFactory.intance().getShopsGroupDataService().getByRetailer(SessionInfo.getInstance().getUser().getRetailer());
			List<ShopsGroupDto> source = new ArrayList<>();
			for (int i = 0; i < allShopsGroupDtoSource.size(); i++) {
				boolean isSave = true;
				for (ShopsGroupDto savedGroupShops: target) {
					if (savedGroupShops.getRecID().equals(allShopsGroupDtoSource.get(i).getRecID())){
						isSave = false;
						break;
					}
				}
				if (isSave){
					source.add(allShopsGroupDtoSource.get(i));
				}
			}
			return new DualListModel<>(source,target);
		}

// Стало. Использовал множество(Set) для работы с группами магазинов
private DualListModel<ShopsGroupDto> initGroupsShopTypeList(){
			Set<ShopsGroupDto> target = this.getEntity().getGroupsShops();
			Set<ShopsGroupDto> allShopsGroupDtoSource = DataServiceFactory.intance().getShopsGroupDataService().getByRetailer(SessionInfo.getInstance().getUser().getRetailer());
			Set<ShopsGroupDto> source = new HashSet<>();
			for (ShopsGroupDto shopGroup : allShopsGroupDtoSource.size()) {
				boolean isSave = true;
				for (ShopsGroupDto savedGroupShops: target) {
					if (savedGroupShops.getRecID().equals(shopGroup.getRecID())){
						isSave = false;
						break;
					}
				}
				if (isSave){
					source.add(shopGroup);
				}
			}
			return new DualListModel<>(source,target);
		}

// Было. Использовал поиндексный доступ к массиву для работы с закладками
public StockGoodBookmarkDto addBookmarkByImporter(String name)
{
	if(!StringUtils.hasValue(name))
		return null;
    for(int i = 0; i < this.getEntity().getBookmarks().size(); i++)
		if(StringUtils.equals(this.getEntity().getBookmarks().get(i).getName(), name))
			return bookmark;
	return this.createBookmark(name);
}

// Стало. Использовал цикл foreach для работы с элементами массива
public StockGoodBookmarkDto addBookmarkByImporter(String name)
{
	if(!StringUtils.hasValue(name))
		return null;
	for(StockGoodBookmarkDto bookmark : this.getEntity().getBookmarks())
		if(StringUtils.equals(bookmark.getName(), name))
			return bookmark;
	return this.createBookmark(name);
}


// Было. Вложенный цикл по перебору значений в разрезе дат. В цикле перебираем массив дат. Для каждой даты в цикле перебираем массив значений
... // много кода
for (int i = 0; i < dateList.size(); i++)
    for (int j = 0; j < valueList.size(); j++)
    {
        ... // много кода
        planValueDto.setDate(convertPlanDates(dateList.get(i), timePeriod));
        planValueDto.setValue(BigDecimal.valueOf(valueList.get(j)));
        ... // много кода
    }

// Стало. Массив дат заменил на Map. Где key - дата, value - список значений для этой даты. Использую entrySet
// для работы с Map. Далее, для каждого списка значений в разрезе даты, использую цикл foreach для работы
// с элементами этого списка
for(Map.Entry<Date, List<Double>> entry : valueMap.entrySet())
{
        for (Double value : entry.getValue())
        {
            ... // много кода
            planValueDto.setDate(convertPlanDates(entry.getKey(), timePeriod));
            planValueDto.setValue(BigDecimal.valueOf(value));
            ... // много кода
        }
}

// Было. Использовал массив для работы с брендами. Использовать цикл по индексам для доступа к элементам массива
List<BrandDto> brandList = DataServiceFactory.intance().getBrandService().getByRetailer(retailer);
Map<String, String[]> shopMap = new HashMap<>();
for(int i = 0; i < brandList.size(); i++)
{
    List<ShopDto> shopList = DataServiceFactory.intance().getShopsService().getByRetailer(retailer, brandList.get(i));
	shopMap.put(brandList.get(i).getName(), shopList.stream().map(ShopDto::getName).collect(Collectors.toList()).toArray(new String[shopList.size()]));
}

// Стало. Использовал множество (Set) для работы с брендами.
Set<BrandDto> brands = DataServiceFactory.intance().getBrandService().getByRetailer(retailer);
Map<String, String[]> shopMap = new HashMap<>();
for(BrandDto brand : brands)
{
    List<ShopDto> shopList = DataServiceFactory.intance().getShopsService().getByRetailer(retailer, brand);
	shopMap.put(brand.getName(), shopList.stream().map(ShopDto::getName).collect(Collectors.toList()).toArray(new String[shopList.size()]));
}

_______________________________________________________________________________________________________
/*
** Комментарии
*/

// 3.1
TypedQuery<StockDto> typedQuery = getEm().createQuery(criteriaQuery);
// Установим лимит выборки
typedQuery.setMaxResults(20);

// Получаем для пользователя признак прочтения акции
ListJoin<StockDto, StockBuyerReadDto> readJoin = root.join(StockDto_.buyerRead, JoinType.LEFT);
readJoin.on(getCriteriaBuilder().equal(readJoin.get(StockBuyerReadDto_.buyer), buyer));
select.add(readJoin.get(StockBuyerReadDto_.readDatetime));

Predicate restrictions = getCriteriaBuilder().conjunction();
// Не черновики
restrictions.getExpressions().add(getCriteriaBuilder().notEqual(root.get(StockDto_.state), StocksStateEnum.Draft));

// Список акций с определенной даты или по-умолчанию
if(updateDate != null)
	restrictions.getExpressions().add(getCriteriaBuilder().or(getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.updateDatetime), updateDate), getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.startDate), updateDate)));
else
	restrictions
	    .getExpressions()
			.add(getCriteriaBuilder().or(getCriteriaBuilder().greaterThan(root.get(StockDto_.startDate), startDate), getCriteriaBuilder().isNull(root.get(StockDto_.finishDate))));

// Дата начала или дата публикации должны наступить (быть менее чем СЕЙЧАС) LEAST(s.StartDate, IFNULL(s.PublishDate,
				// NOW())) < NOW()
				restrictions
					.getExpressions()
					.add(getCriteriaBuilder()
						.lessThan(getCriteriaBuilder()
							.function("LEAST", Date.class, root.get(StockDto_.startDate), getCriteriaBuilder()
								.function("IFNULL", Date.class, root.get(StockDto_.publishDate), getCriteriaBuilder().currentTimestamp())), getCriteriaBuilder().currentTimestamp()));

if(buyer != null)
	// Персональные и общие акции
	restrictions
		.getExpressions()
			.add(getCriteriaBuilder().or(getCriteriaBuilder().equal(buyersJoin.get(BuyerDto_.recID), buyer.getRecID()), getCriteriaBuilder()
			    .and(getCriteriaBuilder().isNull(root.get(StockDto_.auditory)), getCriteriaBuilder().isNull(buyersJoin.get(BuyerDto_.recID)), getCriteriaBuilder().isNull(root.get(StockDto_.byersFilter)))));
else
	// Только общие акции
    restrictions.getExpressions().add(getCriteriaBuilder().and(getCriteriaBuilder().isNull(buyersJoin.get(BuyerDto_.recID)), getCriteriaBuilder()
		.and(getCriteriaBuilder().isNull(root.get(StockDto_.auditory)), getCriteriaBuilder().isNull(root.get(StockDto_.byersFilter)))));

// Поток кластеризации дисконтных карт
@Log4j
public class CardClasteriser extends CustomWorker


// 3.2
// Было
// Кол-во товаров в чеке
check.setGoods(purchase.getPositions().getPosition().size());

// Стало
check.setCheckItems(purchase.getPositions().getPosition().size());

// Было
// Сохраняем карту
card = getCardsDataService().update(card);

// Стало
card = getCardsDataService().save(card);

// Было
/*
** Может вернуть null, если ClientType прийдет полностью пустой.
*/
BuyerDto initBuyer(ClientType clientType, InternalCardType internalCardType, RetailerDto retailer) throws Exception
{
	if(clientType.isNullAllFields())
	    return null;
	.. // Много кода
}

// Стало
BuyerDto initBuyer(ClientType clientType, InternalCardType internalCardType, RetailerDto retailer) throws Exception
{
	if(clientType.isNullAllFields())
	    throw new BuyerNotFoundException();
	.. // Много кода
}

// Было
// Если пароль не подошел и такой карты у нас нет, то создавать карту не нужно.
if(buyer == null && card == null)
	throw new ShopperRestException("Некорректный номер карты или пароль", ShopperHttpResponseCodes.INVALID_CARD_NUMBER_OR_PASSWORD);

// Стало
if(!isPassValid || card == null)
	throw new ShopperRestException("Некорректный номер карты или пароль", ShopperHttpResponseCodes.INVALID_CARD_NUMBER_OR_PASSWORD);

// Было
// Групповой оператор по умолчанию для критерия
private GroupOperationType mainOperation = GroupOperationType.And;

// Стало
private GroupOperationType criteriaGroupOperator = GroupOperationType.And;



_______________________________________________________________________________________________________________________________________-
/*
** Правильные комментарии
*/

// Было
/*
** Признак необходимости обработки бонусных программ
*/
private Boolean useBonus;

// Стало. Пункт 2. Представление намерений
/*
** Признак необходимости обработки бонусных программ. Если этот параметр = true, то при обработке чека необходимо применять бонусный процессинг
*/
private Boolean useBonus;

// Было
/**
 * Мапер для чеков формата SetRetail
**/
public class SetRetailCheckMapper implements IMapperOut<Purchases>

// Стало. Пункт 2. Представление намерений
/**
 * Мапер для чеков формата SetRetail. Класс - обработчик чеков. Здесь выполняется парсинг чека, учитывая различные входные параметры и способы обработки чека
**/
public class SetRetailCheckMapper implements IMapperOut<Purchases>

// Было
// Получаем для пользователя признак прочтения акции
ListJoin<StockDto, StockBuyerReadDto> readJoin = root.join(StockDto_.buyerRead, JoinType.LEFT);
readJoin.on(getCriteriaBuilder().equal(readJoin.get(StockBuyerReadDto_.buyer), buyer));
.. // много кода

// Стало. Пункт 1. Информативные комментарии. Избавились от лишнего комментария
ListJoin<StockDto, StockBuyerReadDto> stocksReadByBuyer = root.join(StockDto_.buyerRead, JoinType.LEFT);
stocksReadByBuyer.on(getCriteriaBuilder().equal(stocksReadByBuyer.get(StockBuyerReadDto_.buyer), buyer));
.. // много кода

// Было
// TODO
select.add(root.get(StockDto_.startDate));

// Стало. Пункт 6. Комментарии TODO
// TODO: По хорошему тут нужно считывать null, но как это сделать по быстрому не нашли
select.add(root.get(StockDto_.startDate));


// Было
if(updateDate != null)
    restrictions.getExpressions().add(getCriteriaBuilder().or(getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.updateDatetime), updateDate), getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.startDate), updateDate)));
else
    restrictions
		.getExpressions()
		    .add(getCriteriaBuilder().or(getCriteriaBuilder().greaterThan(root.get(StockDto_.startDate), startDate), getCriteriaBuilder().isNull(root.get(StockDto_.finishDate))));

// Стало. Пункт 1. Информативные комментарии
// Получаем список акций с определенной даты или по-умолчанию.
if(updateDate != null)
    restrictions.getExpressions().add(getCriteriaBuilder().or(getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.updateDatetime), updateDate), getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.startDate), updateDate)));
else
    restrictions
		.getExpressions()
		    .add(getCriteriaBuilder().or(getCriteriaBuilder().greaterThan(root.get(StockDto_.startDate), startDate), getCriteriaBuilder().isNull(root.get(StockDto_.finishDate))));

// Было
restrictions
    .getExpressions()
		.add(getCriteriaBuilder()
			.lessThan(getCriteriaBuilder()
				.function("LEAST", Date.class, root.get(StockDto_.startDate), getCriteriaBuilder()
				    .function("IFNULL", Date.class, root.get(StockDto_.publishDate), getCriteriaBuilder().currentTimestamp())), getCriteriaBuilder().currentTimestamp()));


// Стало. Пункт 1. Информативные комментарии.
// Дата начала или дата публикации должны наступить (быть менее чем СЕЙЧАС) LEAST(s.StartDate, IFNULL(s.PublishDate, NOW())) < NOW()
restrictions
    .getExpressions()
		.add(getCriteriaBuilder()
			.lessThan(getCriteriaBuilder()
				.function("LEAST", Date.class, root.get(StockDto_.startDate), getCriteriaBuilder()
				    .function("IFNULL", Date.class, root.get(StockDto_.publishDate), getCriteriaBuilder().currentTimestamp())), getCriteriaBuilder().currentTimestamp()));

// Было
// Персональные и общие акции
restrictions
	.getExpressions()
		.add(getCriteriaBuilder().or(getCriteriaBuilder().equal(buyersJoin.get(BuyerDto_.recID), buyer.getRecID()), getCriteriaBuilder()
			.and(getCriteriaBuilder().isNull(root.get(StockDto_.auditory)), getCriteriaBuilder().isNull(buyersJoin.get(BuyerDto_.recID)), getCriteriaBuilder().isNull(root.get(StockDto_.byersFilter)))));

// Стало. Пункт 5. Усиление
// Получаем только персональные и общие акции. Получение и персональных и общих акций здесь очень важно, т.к в ленте необходимо показывать список всех акций.
restrictions
	.getExpressions()
		.add(getCriteriaBuilder().or(getCriteriaBuilder().equal(buyersJoin.get(BuyerDto_.recID), buyer.getRecID()), getCriteriaBuilder()
			.and(getCriteriaBuilder().isNull(root.get(StockDto_.auditory)), getCriteriaBuilder().isNull(buyersJoin.get(BuyerDto_.recID)), getCriteriaBuilder().isNull(root.get(StockDto_.byersFilter)))));

// Было
// Только общие акции
restrictions.getExpressions().add(getCriteriaBuilder().and(getCriteriaBuilder().isNull(buyersJoin.get(BuyerDto_.recID)), getCriteriaBuilder()
    .and(getCriteriaBuilder().isNull(root.get(StockDto_.auditory)), getCriteriaBuilder().isNull(root.get(StockDto_.byersFilter)))));

// Стало. Пункт 5. Усиление
// Получаем только общие акции. Получение только общих акций здесь очень важно, т.к в разделе "Акции" необходимо показывать только общие акции
restrictions.getExpressions().add(getCriteriaBuilder().and(getCriteriaBuilder().isNull(buyersJoin.get(BuyerDto_.recID)), getCriteriaBuilder()
    .and(getCriteriaBuilder().isNull(root.get(StockDto_.auditory)), getCriteriaBuilder().isNull(root.get(StockDto_.byersFilter)))));

// Было
	Predicate predicate = getEm().getCriteriaBuilder().and(
					getEm().getCriteriaBuilder().isNotNull(rootBuyers.get(BuyerDto_.verified)),
					getEm().getCriteriaBuilder().equal(rootBuyers.get(BuyerDto_.retailer), retailer));

// Стало. Пункт 6. Комментарии TODO
Predicate predicate = getEm().getCriteriaBuilder().and(
    // TODO: Определять наличие девайса только значению verified не правильно. Правильнее выполнять join с buyers.devices. Будет доработано в версии 1.2.2
    getEm().getCriteriaBuilder().isNotNull(rootBuyers.get(BuyerDto_.verified)),
    getEm().getCriteriaBuilder().equal(rootBuyers.get(BuyerDto_.retailer), retailer));

// Было
public static Date lastSecondOfDay(Date date)
{
	if(hasTime(date))
		return date;
	Calendar calendar = Calendar.getInstance();
	calendar.setTime(date == null ? DateUtils.now() : date);
	calendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH));
	calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH));
	calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR));
	calendar.set(Calendar.HOUR_OF_DAY, 23);
	calendar.set(Calendar.MINUTE, 59);
	calendar.set(Calendar.SECOND, 59);
	return calendar.getTime();
}

// Стало. Пункт 1. Информативные комментарии
	/**
		 * Получить время окончания дня. 23:59:59
		 *
		 * @param date
		 * @return
		 */
public static Date lastSecondOfDay(Date date)
{
	if(hasTime(date))
		return date;
	Calendar calendar = Calendar.getInstance();
	calendar.setTime(date == null ? DateUtils.now() : date);
	calendar.set(Calendar.DAY_OF_MONTH, calendar.get(Calendar.DAY_OF_MONTH));
	calendar.set(Calendar.MONTH, calendar.get(Calendar.MONTH));
	calendar.set(Calendar.YEAR, calendar.get(Calendar.YEAR));
	calendar.set(Calendar.HOUR_OF_DAY, 23);
	calendar.set(Calendar.MINUTE, 59);
	calendar.set(Calendar.SECOND, 59);
	return calendar.getTime();
}

// Было
public static boolean hasTime(Date value)
{
	if(value == null)
		return false;
	Calendar calendar = Calendar.getInstance();
	calendar.setTime(value);
	return calendar.get(Calendar.HOUR_OF_DAY) > 0 || calendar.get(Calendar.MINUTE) > 0 || calendar.get(Calendar.SECOND) > 0 || calendar.get(Calendar.MILLISECOND) > 0;
}

// Стало. Пункт 1. Информативные комментарии
/**
 * Проверить задано ли время в указанном значении.
 *
 * @param value
 * @return
 */
public static boolean hasTime(Date value)
{
	if(value == null)
		return false;
	Calendar calendar = Calendar.getInstance();
	calendar.setTime(value);
	return calendar.get(Calendar.HOUR_OF_DAY) > 0 || calendar.get(Calendar.MINUTE) > 0 || calendar.get(Calendar.SECOND) > 0 || calendar.get(Calendar.MILLISECOND) > 0;
}

// Было
setGoodList(logPrefix, check, retailerAccount.getRetailer(), purchase);
setPayment(logPrefix, check, purchase.getPaymentList());
check = DataServiceFactory.intance().getChecksService().update(check);

// Стало. Пункт 6. Комментарии TODO
setGoodList(logPrefix, check, retailerAccount.getRetailer(), purchase);
setPayment(logPrefix, check, purchase.getPaymentList());
// TODO: Нужно решить проблему с транзакциями, которая возникает при сохранении чека и несуществующего товара. Будет доработано в версии 1.1.2
check = DataServiceFactory.intance().getChecksService().update(check);

__________________________________________________________________________________________________

/*
** Плохие комментарии
*/

// Было
/**
 * Получить текущую дату в виде строки в формате simpleDateFormat.
 *
 * @return
 */
public static String getDate()
{
	return DateFormats.instance().getSimpleDateFormat().format(new Date());
}

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
public static String getDateInSimpleFormat()
{
	return DateFormats.instance().getSimpleDateFormat().format(new Date());
}

// Было
/**
  * Получить дату в виде строки в формате simpleDateFormat.
  *
  * @param value
  * @return
  */
public static String getDate(Date value)
{
	return value == null? "": DateFormats.instance().getSimpleDateFormat().format(value);
}

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
public static String getDateStringInSimpleFormat(Date value)
{
	return value == null? "": DateFormats.instance().getSimpleDateFormat().format(value);
}

// Было
/**
  * Добавить месяцы к дате
  *
  * @param value
  * @return
  */
public static Date addMonth(Date date, Integer value)
{
	GregorianCalendar calen = new GregorianCalendar();
	calen.setTime(date);
    calen.add(Calendar.MONTH, value);
	return calen.getTime();
}

// Cтало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
public static Date addMonthToDate(Date date, Integer value)
{
	GregorianCalendar calen = new GregorianCalendar();
	calen.setTime(date);
    calen.add(Calendar.MONTH, value);
	return calen.getTime();
}

// Было
// TODO Переименовать метод
public Boolean getPersonalForAuditory()
{
    return StockPersonalTypeEnum.Auditory.equals(this.stockPersonalType) ||
		StockPersonalTypeEnum.Criteria.equals(this.stockPersonalType);
}

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
public Boolean isStockPersonal()
{
    return StockPersonalTypeEnum.Auditory.equals(this.stockPersonalType) ||
		StockPersonalTypeEnum.Criteria.equals(this.stockPersonalType);
}

// Было
// Этот список получается при импорте значений из файла
List<PlanForecastValueDto> planTempList = getDataService().getAddedValueList().stream().filter(o -> planValue != null && getDataService().isDatesEqualsByTimePeriod(o, planValue) && getDataService().isEqualsSalesPoint(o, planValue) && o.getMetric().equals(planValue.getMetric())).collect(Collectors.toList());
PlanForecastValueDto planTempValue = !planTempList.isEmpty()? planTempList.get(0): null;
.. // много кода

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
List<PlanForecastValueDto> importedPlanList = getDataService().getAddedValueList().stream().filter(o -> planValue != null && getDataService().isDatesEqualsByTimePeriod(o, planValue) && getDataService().isEqualsSalesPoint(o, planValue) && o.getMetric().equals(planValue.getMetric())).collect(Collectors.toList());
PlanForecastValueDto planTempValue = !planTempList.isEmpty()? planTempList.get(0): null;
.. // много кода

// Было
// Добавляем группы магазинов в дерево
List<ShopsGroupDto> shopGroupList = DataServiceFactory.intance().getShopsGroupDataService().getByRetailer(retailer);
brandMap = new HashMap<>();
shopMap = new HashMap<>();
for(ShopsGroupDto shopGroup : shopGroupList)
{
	List<ShopDto> shopList = DataServiceFactory.intance().getShopsService().getByShopGroup(shopGroup.getRecID());
    shopMap.put(shopGroup.getName(), shopList.stream().map(ShopDto::getName).collect(Collectors.toList()).toArray(new String[shopList.size()]));
}
brandMap.put("shopGroups", shopMap);
.. // много кода

// Стало. Пункт 4. Шум. Комментарий тут не нужен, т.к и так понятно, что происходит в коде
List<ShopsGroupDto> shopGroupList = DataServiceFactory.intance().getShopsGroupDataService().getByRetailer(retailer);
brandMap = new HashMap<>();
shopMap = new HashMap<>();
for(ShopsGroupDto shopGroup : shopGroupList)
{
	List<ShopDto> shopList = DataServiceFactory.intance().getShopsService().getByShopGroup(shopGroup.getRecID());
    shopMap.put(shopGroup.getName(), shopList.stream().map(ShopDto::getName).collect(Collectors.toList()).toArray(new String[shopList.size()]));
}
brandMap.put("shopGroups", shopMap);
.. // много кода

// Было
// Если пароль не подошел и такой карты у нас нет, то создавать карту не нужно.
if(buyer == null && card == null)
    throw new ShopperRestException("Некорректный номер карты или пароль", ShopperHttpResponseCodes.INVALID_CARD_NUMBER_OR_PASSWORD);

// Стало. Пункт 2. Бормотание. Переписал комментарий
// Если покупатель и карта не найдены в нашей БД, то считаем, что пользователь ввел некорректный номер карты или пароль
if(buyer == null && card == null)
    throw new ShopperRestException("Некорректный номер карты или пароль", ShopperHttpResponseCodes.INVALID_CARD_NUMBER_OR_PASSWORD);

// Было
// Если ни пароль не подошел и такой карты у нас нет, то создавать карту не нужно.
if(card.getBuyer() != null && !card.getBuyer().getRecID().equals(buyer.getRecID()) && card.getBuyer().getVerified() != null)
    throw new ShopperRestException("Указанная карта %s уже зарегестрирована на другого покупателя", ShopperHttpResponseCodes.CARD_ALREADY_BINDING_BUYER);

// Стало. Пункт 2. Бормотание. Переписал комментарий
// Если у карты нет покупателя или покупатель, привязанные к карте отличается от авторизованного покупателя,
// и покупателя, привязанного к карте, подтвержден номер телефона, то считаем, что карта уже привязана к другому покупателя
// и не даем возможности ее использовать
if(card.getBuyer() != null && !card.getBuyer().getRecID().equals(buyer.getRecID()) && card.getBuyer().getVerified() != null)
    throw new ShopperRestException("Указанная карта %s уже зарегестрирована на другого покупателя", ShopperHttpResponseCodes.CARD_ALREADY_BINDING_BUYER);


// Было
/**
	 * Зарегистрировать физическую карту
	 * @return
	 * @throws Exception
	 */
	@Path("/material")
	@POST
	@Authenticated
	public CardJSON register(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(NumberParamName) String number) throws Exception
	{
	.. // много кода
	}

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
	@Path("/material")
	@POST
	@Authenticated
	public CardJSON registerMaterialCard(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(NumberParamName) String number) throws Exception
	{
	.. // много кода
	}

// Было
/**
 ** Зарегистрировать виртуальную карту
 */
	@POST
	@Path("/virtual")
	@Authenticated
	public CardJSON registerVirtual(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID) throws Exception
	{
	.. // много кода
	}

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
    @POST
	@Path("/virtual")
	@Authenticated
	public CardJSON registerVirtualCard(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID) throws Exception
	{
	.. // много кода
	}

// Было
/*
** Получить чек
*/
		@POST
		@IntergationAuthenticated
		@Path("/getProcessedCheck")
		public CheckJSON getProcessedCheck(
			@NotNull @QueryParam(RetailerParamName) String retailerCode,
			@CheckRetailerToken @QueryParam(ApiKeyParamName) String apiKey,
			@NotNull @QueryParam(CardNumberParamName) String cardNumber,
			CheckJSON check
		) throws Exception
		{
		.. // много кода
		}

// Стало. Пункт 1. Неочевидные комментарии
/*
** Получить чек, после применения к нему скидок + остаток бонусов на счету покупателя, доступных для списания	 *
*/
		@POST
		@IntergationAuthenticated
		@Path("/getProcessedCheck")
		public CheckJSON getProcessedCheck(
			@NotNull @QueryParam(RetailerParamName) String retailerCode,
			@CheckRetailerToken @QueryParam(ApiKeyParamName) String apiKey,
			@NotNull @QueryParam(CardNumberParamName) String cardNumber,
			CheckJSON check
		) throws Exception
		{
        .. // много кода
        }

// Было
 /**
   * Обработать новые акции
   */
    private void processNewStock(List<StockDto> newStockList)
	{
      .. // много кода
    }

// Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий
    private void processNewStock(List<StockDto> newStockList)
	{
      .. // много кода
    }

// Было
 /**
   * Обработать повторно выгружаемые акции
   */
    private void processExportedStock(List<StockDto> exportedStockList)
    {
        .. // много кода
    }

 // Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал метод
 private void processAlreadyExportedStock(List<StockDto> exportedStockList)
 {
    .. // много кода
 }

 // Было
 public List<StockDto> getForBonusCalculation(Date minDate)
 		{
 				CriteriaQuery<StockDto> query = getCriteriaBuilder().createQuery(StockDto.class);
 				Root<StockDto> root = query.from(StockDto.class);
 				// StartDate <= now() AND (FinishDate IS NULL OR FinishDate >= '20171201' ) AND (State IN ('Approved', 'Completed'))
 				// AND (Bonus IS NOT NULL)
 				query
 					.where(getCriteriaBuilder().lessThanOrEqualTo(root.get(StockDto_.startDate), getCriteriaBuilder().currentDate()), getCriteriaBuilder()
 						.or(getCriteriaBuilder().isNull(root.get(StockDto_.finishDate)), getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.finishDate), minDate)), root
 						.get(StockDto_.state)
 						.in(StocksStateEnum.Approved, StocksStateEnum.Completed), getCriteriaBuilder().isNotNull(root.get(StockDto_.bonus)));
 				return getEm().createQuery(query).getResultList();
 		}

  // Стало. Пункт 12. Закомментированный код. Убрал закомментированный код
  public List<StockDto> getForBonusCalculation(Date minDate)
  {
  		CriteriaQuery<StockDto> query = getCriteriaBuilder().createQuery(StockDto.class);
        Root<StockDto> root = query.from(StockDto.class);
        query
            .where(getCriteriaBuilder().lessThanOrEqualTo(root.get(StockDto_.startDate), getCriteriaBuilder().currentDate()), getCriteriaBuilder()
          	.or(getCriteriaBuilder().isNull(root.get(StockDto_.finishDate)), getCriteriaBuilder().greaterThanOrEqualTo(root.get(StockDto_.finishDate), minDate)), root
          	.get(StockDto_.state)
          	.in(StocksStateEnum.Approved, StocksStateEnum.Completed), getCriteriaBuilder().isNotNull(root.get(StockDto_.bonus)));
        return getEm().createQuery(query).getResultList();
  }

  // Было
  private final Integer checkRowInSupplierAndCardForm = 10; // Счетчик строк

  // Стало. Пункт 8. Избыточные комментарии. Убрал лишний комментарий, переименовал переменную
  private final Integer rowCounter = 10;
