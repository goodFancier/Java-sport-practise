/*
** Баги в наименовании
*/
// сеттер для поля isNeedToCalculateAllShops
needToCalculateAllShops - setNeedToCalculateAllShops

// метод, вызываемый при изменении вкладки
changeTab - onChangeTab

// Обновить статус товара
statusDelivered - updateOrderStatus


/*
** Рефакторинг имен переменных
*/
sqlTimeConditions - timeConditions

sqlShopsConditions - shopConditions

sqlConditionList - conditions

sqlBrandConditionList - brandConditions

tabId - planningTabId

allDetailingObjects - detailingObjectList

availableYears - availableYearList

filterYears - filterYearQueue

sizesOfPlanValues - planValueListSize

name - buyerName

age - buyerAge

order - receiptOrder

checkedSignificantBrandList - checkedSignificantBrands

getIsNeedToShowAddDialog - isNeedToShowDialog

/*
** Имена переменных
*/

// 7.1
processCompleted - isProcessCompleted

isNeedToUpdate - doNeedUpdate

isCalculatingError - hasCalculatingError

isMessageSendingStopped - doMailingStopped

queryRunning - isQueryRunning

// 7.2
processFinished - isProcessDone

isElementExists - isElementFound

// 7.3

i - element

// 7.4
isMailingStarted, isMailingFinished - isMailingBegin, isMailingEnd

// 7.5
tmpSelectItemChecks - selectItemChecks
tmpStart - dateStart
tmpFinish - dateFinish

/*
** Имена, которых следует избегать
*/

allChannelsForRetailer - allChannels

filteredByEmailAndSmsChannelList - emailSmsChannels

addChannelsNotification - allowAllChannelsToBuyer

channelsDtoDualListModel - channelDualList

consumerList - consumers

goodsValue - goodsCount

buyerList1 - buyerOriginalList

buyerList2 - buyerProcessedList

retailerObject - retailer

guaranteedMessageDeliveryScheduler - msgDeliveryScheduler

max - maxSumOfCheck

value - checkValue

/*
** Имена классов
*/

// 3.1
CreatePage - PageConstructor

RuleManager - RuleController

EntityInfo - EntityPayload

CheckDeserializeProcessor - CheckDeserializer

CardDeserializeProcessor - CardDeserializer

// 3.2

initCheckFile - initDocument (реализация абстрактного метода)

initCardFile - initDocument (реализация абстрактного метода)

applyDiscountMechanic - applyMechanic (реализация абстрактного метода)

applyBonusMechanic - applyMechanic (реализация абстрактного метода)

bonusRuleManager - ruleManager

discountRuleManager - ruleManager

pull - pullResult

/*
** Имена функций/методов
*/

sendMessageAndCheckDelivery - sendMessage() - checkDelivery() - разделил один метод на два, убрав побочные действия метода

runSmsExecutorAndSaveToFile - runSmsExecutor() - saveResultToFile() - разделил один метод на два, убрав побочные действия метода

getViberJSONObjectAndSendMessage - getViberJSON() - sendMessage() - разделил один метод на два, убрав побочные действия метода

editName - setName - переименовал метод для изменения имени

reloadPage() - reload() - поправил название метода, т.к метод reload относится к классу Page

sendMessage() - send() - поправил название метода, т.к метод send относится к классу Message

taxiOrderToComplete() - completeTaxiOrder() - поправил название метода

lastMessageToFind() - findLastMessage() - поправил название метода

pageReload() - reloadPage() - поправил название метода

Element element = prevElement.add(20) - int element = prevElement.setIndex(20) - переименовал методв add в setIndex

Date date = prevDate.add(20) - Date date = prevDate.addMinutes(20);

entityToUpdate() - updateEntity() - поправил название метода

/*
** ООП и интерфейсы
*/

// 3.1
//  Метод-фабрика DataServiceFactory
    public static synchronized DataServiceFactory getInstance()
    		{
    				if(instance == null)
    						synchronized(DataServiceFactory.class)
    						{
    								try
    								{
    										if(instance == null)
    										{
    												InitialContext context = new InitialContext();
    												instance = (DataServiceFactory)context.lookup("java:module/DataServiceFactory");
    										}
    								}
    								catch(Exception e)
    								{
    										ExceptionHandler.handle(e);
    								}
    						}
    				return instance;
    		}

// Метод-фабрика AuditoryOperatorFactory
AuditoryOperatorFactory auditoryOperatorFactory = new AuditoryOperatorFactory(stock) - AuditoryOperatorFactory.fromStock(stock);

// Метод-фабрика BonusOperatorFactory
BonusOperatorFactory bonusOperatorFactory = new BonusOperatorFactory(bonus) - BonusOperatorFactory.fromBonus(bonus);

// 3.2
IDiscountMechanic - DiscountMechanic
IRuleManager - RuleManager
IBonusMechanic - BonusMechanic

/*
** Константы
*/

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String NumberParamName = "number";
public CardJSON register(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(NumberParamName) String number) throws Exception

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String CardIDParamName = "cardID";

public CardJSON getCard(
		@NotNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
		@CheckBuyer @NotNull @QueryParam(BaseRestORMService.BuyerIDParamName) Long buyerID,
		@NotNull @QueryParam(CardIDParamName) Long cardID)
	{
		return getJSON(DataServiceFactory.intance().getCardsService().findById(cardID));
	}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String LoginParamName = "login";

	public BuyerJSON loginByHashPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(LoginParamName) String cardNumber,
			@NonNull String password,
			@QueryParam(DeviceParamName) String deviceID) throws Exception
		{
				return internalLogin(retailer, cardNumber, password, deviceID);
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
public static final String PasswordParamName = "password";

public BuyerJSON loginByPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailer,
			@NonNull @QueryParam(LoginParamName) String cardNumber,
			@NonNull @QueryParam(PasswordParamName) String password,
			@QueryParam(DeviceParamName) String deviceID,
			@QueryParam(BuyerIDParamName) Long buyerID,
			@QueryParam(BaseRestORMService.isNewLogic) Boolean... newLogic) throws Exception
		{
				if(newLogic.length > 0)
						return internalLogin(retailer, cardNumber, password, deviceID, buyerID);
				else
						return internalLogin(retailer, cardNumber, password, deviceID);
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String CardNumberParamName = "cardNumber";

	@POST
		@Path("/register/material4")
		@AccessAll
		public BuyerJSON registrationMaterialByHashPass(
			@NonNull @QueryParam(BaseRestORMService.RetailerParamName) String retailerCode,
			@NotNull @QueryParam(BaseRestORMService.BuyerParamName) BuyerJSON buyer,
			@NonNull @QueryParam(CardNumberParamName) String login,
			@NonNull String password,
			@QueryParam(DeviceParamName) String gmcid) throws Exception
		{
				return internalRegisterMaterial(retailerCode, login, password, gmcid, (o) -> createFromJSON(buyer));
		}

// Добавлена константа для использования ее для именования входного параметра рест метода
private static final String DeviceCheckParamName = "deviceCheck";

//Скидка по умолчанию
private static final Double DefaultDiscount = 0d;

// Формат даты
private static final DateFormat SimpleDateFormat = new SimpleDateFormat("yyyyMMdd");

// Формат даты
private static final DateFormat BirthDayDateFormat = new SimpleDateFormat("MMdd");

// Формат даты
private static final SimpleDateFormat GUIDateTimeFormat = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");

// Формат даты
private static final SimpleDateFormat JQPlotDateTimeFormat = new SimpleDateFormat("MM.dd.yyyy HH:mm");

// Формат даты
private static final DateFormat FilenameDateTimeFormat = new SimpleDateFormat("ddMMyyyy HHmm");



/*
** Типы данных
*/

// использование unicode
String json = new String(body, StandardCharsets.UTF_8);

// Добавлена проверка на 0
if (checkItem.getQuantity() <> 0)
    checkItem.setPrice(checkItem.getSum().divide(checkItem.getQuantity()));

// Добавлена локализация
CategoryAxis axisX = new CategoryAxis(Localization.loadString("IndicatorController.categoryAxis.label.months"));

// Добавлена локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("IndicatorController.lineChartModel.axisY.label.checkNumber"));

// Добавлена локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("IndicatorController.lineChartModel.axisY.label.buyerNumber"));


// Дополнительные булевые переменные
// Было
if(MechanicManager.getInstance().getDiscountMechanics()
									.get(buyerDiscountStocks.get(i).getStockDiscountMechanic() != null? buyerDiscountStocks.get(i).getStockDiscountMechanic(): StockDiscountMechanicEnum.DiscountOnGood)
									.isCheckItemFitsRequirements(processedCheck, processedCheckItem, buyerDiscountStocks.get(i)))

// Стало

Boolean isCheckFitsRequirements = MechanicManager.getInstance().getDiscountMechanics()
									.get(buyerDiscountStocks.get(i).getStockDiscountMechanic() != null? buyerDiscountStocks.get(i).getStockDiscountMechanic(): StockDiscountMechanicEnum.DiscountOnGood)
									.isCheckItemFitsRequirements(processedCheck, processedCheckItem, buyerDiscountStocks.get(i))
									if (isCheckFitsRequirements)

// использование unicode
xStream.toXML(dest).getBytes(StandardCharsets.UTF_8);


// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.amountOfChecks"));

// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.numberOfCheck"));

// локализация
dateModel.getAxis(AxisType.Y).setLabel(Localization.loadString("AnaliticsController.lineChartModel.label.averageOfChecks"));

// использование unicode
HttpEntity entity = new StringEntity(json, StandardCharsets.UTF_8);

// использование unicode
bundle = new PropertyResourceBundle(new InputStreamReader(stream, StandardCharsets.UTF_8));


/*
** Переменные и их значения
*/

// Было
int planningStartValue = 100;
... // Много кода
String result = planningStartValue / 2;

// Стало
... // Много кода
int planningStartValue = 100;
String result = planningStartValue / 2;

// Было
public boolean notify(StockDto stock, Boolean calculateBadges)
{
NotificationEntity notificationEntity = new NotificationEntity();
						notificationEntity.setRetailerCode(stock.getRetailer().getCode());
						notificationEntity.setIsDebug(VersionUtils.getIsDebug());
... // Много кода
notificationSender.send(KeyConfig.KEY_COMMAN_STOCK.getTitle(), KeyConfig.KEY_COMMAN_STOCK.getTitle(), new Gson().toJson(notificationEntity));
}

// Стало
public boolean notify(StockDto stock, Boolean calculateBadges)
{
... // Много кода
NotificationEntity notificationEntity = new NotificationEntity();
						notificationEntity.setRetailerCode(stock.getRetailer().getCode());
						notificationEntity.setIsDebug(VersionUtils.getIsDebug());
notificationSender.send(KeyConfig.KEY_COMMAN_STOCK.getTitle(), KeyConfig.KEY_COMMAN_STOCK.getTitle(), new Gson().toJson(notificationEntity));
notificationSender = null;
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
		JSONObject psItem;
		... // Много кода
		psItem = (JSONObject)jsonTreeElementArray.get(j);
        								String key = psItem.keys().next();
        								Object value = psItem.get(key);
        ... // Много кода
}

// Стало
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
        ... // Много кода
		JSONObject psItem;
		psItem = (JSONObject)jsonTreeElementArray.get(j);
        								String key = psItem.keys().next();
        								Object value = psItem.get(key);
        psItem = null;
}

// Было
int plansSize = 0;
while (plansSize < 10)
{
    ... // Много кода
    plansSize++;
}

// Стало
int plansSize = 0;
for (int i=0; i < 10; i++)
{
    ... // Много кода
    plansSize++;
}

// Было
int resultListSize = 0;
while (true)
{
    ... // Много кода
    if (resultListSize >= 10)
        break;
}

// Стало
for (int i=0; i < 10; i++)
{
    ... // Много кода
}

// Было
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values`");
     ... // Много кода

}

// Стало
public void errorsEvent(JSONArray jsonArray, HttpServletResponse response) throws IOException
{
    StringBuilder sqlConditions = new StringBuilder("SELECT er.ErrorMessage FROM `analytics.plansandforecasts.values`");
     ... // Много кода
    sqlConditions = null;
}

// Было
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
    Map<String, List<String>> timeIntervalListMap = new HashMap<>();
     ... // Много кода
}

// Стало
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
    Map<String, List<String>> timeIntervalListMap = new HashMap<>();
     ... // Много кода
     timeIntervalListMap = null;
}

// Было
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
	String lastQuarter = "";
	... //  Много кода
}

// Cтало
private void fillSubTreeList(JSONArray jsonArray, List<Map<String, List<String>>> subTreeList)
{
	String lastQuarter = "";
	... //  Много кода
	lastQuarter = null;
}

// Было
public void executeClastering(RetailerDto retailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	ClusteringMechanism clustering = new ClusteringMechanism();
	Map<List<Long>, List<Integer>> resultTagCardMap;
	... //  Много кода
	resultTagCardMap = clustering.getClasterResults(retailer, getRepository().getTagStatisticByRetailer(retailer, analysisScenario, rank), analysisScenario);
}

// Стало
public void executeClastering(RetailerDto retailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... //  Много кода
	ClusteringMechanism clustering = new ClusteringMechanism();
    Map<List<Long>, List<Integer>> resultTagCardMap;
	resultTagCardMap = clustering.getClasterResults(retailer, getRepository().getTagStatisticByRetailer(retailer, analysisScenario, rank), analysisScenario);
}

// Было
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	List<List<Long>> resultClasterCards = new ArrayList<>();
	... //  Много кода
}

// Стало
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	List<List<Long>> resultClasterCards = new ArrayList<>();
	... //  Много кода
	resultClasterCards = null;
}

// Было
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... // Много кода
	KMeansParams.Builder builder = new KMeansParams.Builder();
	... // Много кода
}

// Стало
public Map<List<Long>, List<Integer>> getClasterResults(RetailerDto retailer, Map<Long, Map<Double, Double>> tagStatisticByRetailer, AnalysisScenarioEnum analysisScenario) throws Exception
{
	... // Много кода
	KMeansParams.Builder builder = new KMeansParams.Builder();
	builder = null;
}

// Было
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    double minSup = retailer.getSupportCoefficient().doubleValue();
    ... // Много кода
    for(int i = 0; i < this.itemsets.size(); i++)
    						if((count[i] / (double)(this.numTransactions)) >= this.minSup)
    					... // Много кода
}

// Стало
public void configApriori(RetailerDto retailer, String pathToFrequentItems, EntityManager em)
{
    ... // Много кода
    double minSup = retailer.getSupportCoefficient().doubleValue();
    for(int i = 0; i < this.itemsets.size(); i++)
    						if((count[i] / (double)(this.numTransactions)) >= this.minSup)
    					... // Много кода
}

// Было
 public static List<Integer> getCategoryIntersections(List<Integer> goodCategoryList, EntityManager em, RetailerDto retailer)
 {
 	ArrayList<ArrayList<Integer>> tuplelist = new ArrayList<>();
 	... // Много кода
 }

 // Стало
 public static List<Integer> getCategoryIntersections(List<Integer> goodCategoryList, EntityManager em, RetailerDto retailer)
 {
 	ArrayList<ArrayList<Integer>> tuplelist = new ArrayList<>();
 	... // Много кода
 	tuplelist = null;
 }

// Было
private void calculateFrequentItemsets(RetailerDto retailer, EntityManager em)
{
    List<int[]> frequentCandidates = new ArrayList<int[]>(); // the frequent candidates for the current itemset.
    ... // Много кода
}

// Стало
private void calculateFrequentItemsets(RetailerDto retailer, EntityManager em)
{
    List<int[]> frequentCandidates = new ArrayList<int[]>(); // the frequent candidates for the current itemset.
    ... // Много кода
    frequentCandidates = null;
}


// Было
private void createNewItemsetsFromPreviousOnes()
{
    int currentSizeOfItemsets = this.itemsets.get(0).length;
    ... // Много кода
    int[] newCand = new int[currentSizeOfItemsets + 1];
    ... // Много кода
}

// Стало
private void createNewItemsetsFromPreviousOnes()
{
    ... // Много кода
    int currentSizeOfItemsets = this.itemsets.get(0).length;
    int[] newCand = new int[currentSizeOfItemsets + 1];
    ... // Много кода
    currentSizeOfItemsets = null;
    newCant = null;
}
